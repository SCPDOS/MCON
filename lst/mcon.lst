     1                                  [map all ./lst/mcon.map]
     2                                  DEFAULT REL
     3                                  BITS 64
     4                                  
     5                                  %include "./src/drvStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     4                              <1> ; device driver related structures.                     ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> struc drvHdr  ;Device Driver Header for character and block devices
     8                              <1> 
     9 00000000 ????????????????    <1>     .nxtPtr dq ?  ;Pointer to the next driver header, -1 if at the end
    10 00000008 ????                <1>     .attrib dw ?  ;Attribute Word
    11 0000000A ????????????????    <1>     .strPtr dq ?  ;Strategy Entry Pointer
    12 00000012 ????????????????    <1>     .intPtr dq ?  ;Interrupt Entry Pointer
    13                              <1>     .drvUnt:        ;Number of units pointer
    14 0000001A ????????????????    <1>     .drvNam db 8 dup (?)  ;Driver name (Char) or Number of units byte (Block)
    15                              <1> 
    16                              <1> endstruc
    17                              <1> 
    18                              <1> ;Command Code equates
    19                              <1>     drvINIT         equ 0
    20                              <1>     drvMEDCHK       equ 1
    21                              <1>     drvBUILDBPB     equ 2
    22                              <1>     drvIOCTLREAD    equ 3
    23                              <1>     drvREAD         equ 4
    24                              <1>     drvNONDESTREAD  equ 5
    25                              <1>     drvINSTATUS     equ 6
    26                              <1>     drvFLUSHINBUF   equ 7
    27                              <1>     drvWRITE        equ 8
    28                              <1>     drvWRITEVERIFY  equ 9
    29                              <1>     drvOUTSTATUS    equ 10
    30                              <1>     drvFLUSHOUTBUF  equ 11
    31                              <1>     drvIOCTLWRITE   equ 12
    32                              <1>     drvOPEN         equ 13
    33                              <1>     drvCLOSE        equ 14
    34                              <1>     drvREMMEDCHECK  equ 15
    35                              <1>     drvOUTTILBUSY   equ 16  ;Not implemented
    36                              <1>     drvIOCTL        equ 19
    37                              <1>     drvGETDRVMAP    equ 23
    38                              <1>     drvSETDRVMAP    equ 24
    39                              <1>     
    40                              <1> ;Driver Error equates 
    41                              <1>     drvWPErr        equ 0   ;Write Protect Violation
    42                              <1>     drvBadUnit      equ 1   ;Unknown unit
    43                              <1>     drvNotReady     equ 2   ;Device not ready
    44                              <1>     drvBadCmd       equ 3   ;Unknown command
    45                              <1>     drvCRCErr       equ 4   ;CRC Error
    46                              <1>     drvBadDrvReq    equ 5   ;Bad drive request structure length
    47                              <1>     drvBadSeek      equ 6   ;Seek error
    48                              <1>     drvBadMed       equ 7   ;Unknown media
    49                              <1>     drvSecNotFnd    equ 8   ;Sector not found
    50                              <1>     drvNoPaper      equ 9   ;Printer out of paper
    51                              <1>     drvWriteFault   equ 10  ;Write Fault
    52                              <1>     drvReadFault    equ 11  ;Read Fault
    53                              <1>     drvGenFault     equ 12  ;General Fault
    54                              <1>     drvBadDskChnge  equ 15  ;Invalid disk change
    55                              <1> 
    56                              <1> ;Driver status word status bit meanings
    57                              <1>     drvErrStatus    equ 8000h  
    58                              <1>     drvDonStatus    equ 0100h
    59                              <1>     drvBsyStatus    equ 0200h
    60                              <1> 
    61                              <1> ;Driver Attribute Word bit meanings
    62                              <1>     devDrvConIn    equ 1h  ;If set, device is CON input
    63                              <1>     devDrvConOut   equ 2h  ;If set, device is CON output
    64                              <1>     devDrvNulDev   equ 4h  ;If set, device is NULL device
    65                              <1>     devDrvClockDev equ 8h  ;If set, device is CLOCK device
    66                              <1>     devDrvFastOut  equ 10h ;If set, device supports Int 29h
    67                              <1>     devDrvMulti    equ 20h ;Reserved, If set, device is multitasking. 
    68                              <1>     devDrvIOCTL    equ 40h ;If set, IOCTL and GET/SET suported
    69                              <1>     devDrvHdlCTL   equ 800h ;If set, Open, Close and Rem media supported
    70                              <1>     devDrvIOCTLRW  equ 4000h ;If set, IOCTL Read/Write supported
    71                              <1>     devDrvChar     equ 8000h ;If set, Char device
    72                              <1> ;Bit 0 1=console input
    73                              <1> ;    1 1=console output (character devices)
    74                              <1> ;    2 1=NUL device
    75                              <1> ;    3 1=CLOCK device
    76                              <1> ;    4 1=Int 29 output (CON)
    77                              <1> ;    5 1=Multitasking driver. Bit ignored by DOS. Used by multitaskers.
    78                              <1> ; If bit set, no crit2 lock placed on thread when making drv request.
    79                              <1> ;    6 1=extended functions supported (13,17,18) (3.2+)
    80                              <1> ;    7 1=Generic IOCTL function supported (19)
    81                              <1> ;   11 1=open/close/removable media supported (3.0+)
    82                              <1> ;   13 1=output until busy supported (character devices) (3.0+)
    83                              <1> ;      1=media descriptor in FAT required (block devices)
    84                              <1> ;   14 1=IOCTL R/W supported
    85                              <1> ;   15 0=block device
    86                              <1> ;      1=character device
    87                              <1> 
    88                              <1> ;Driver structures
    89                              <1> 
    90                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    91                              <1> 
    92                              <1>     .hdrlen db ?  ;Length of the request header
    93                              <1>     .unitnm db ?  ;Unit number, meaningless for character devs
    94                              <1>     .cmdcde db ?  ;Command code
    95                              <1>     .status dw ?  ;Status word
    96                              <1>     .devptr dq ?  ;Device queue pointer field, reserved for future use
    97                              <1> 
    98                              <1> %endmacro
    99                              <1> 
   100                              <1> struc drvReqHdr
   101                              <1>     drvReqHdrM
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   102                              <1> endstruc
   103                              <1> 
   104                              <1> struc initReqPkt  ;Init Request Packet
   105                              <1> 
   106                              <1>     drvReqHdrM   ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   107 0000000D ??                  <1>     .numunt db ?  ;Number of logical units (Block only, 0 for char)
   108 0000000E ????????????????    <1>     .endptr dq ?  ;Pointer to first free byte after driver
   109 00000016 ????????????????    <1>     .optptr dq ?  ;Ptr to BPB array (blkdev) or cmdline args
   110 0000001E ??                  <1>     .drvnum db ?  ;First Drive number
   111                              <1> 
   112                              <1> endstruc
   113                              <1> 
   114                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
   115                              <1> 
   116                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   117 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   118 0000000E ??                  <1>     .medret db ?  ;Return byte (Has media been changed?)
   119 0000000F ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field
   120                              <1> 
   121                              <1> endstruc
   122                              <1> 
   123                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
   124                              <1> 
   125                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   126 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   127 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   128 00000016 ????????????????    <1>     .bpbptr dq ?  ;Pointer to the BPB
   129                              <1> 
   130                              <1> endstruc
   131                              <1> 
   132                              <1> struc ioReqPkt   ;IO Request Packet
   133                              <1> 
   134                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   135 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   136 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   137 00000016 ????????            <1>     .tfrlen dd ?  ;Number of Sectors/bytes to transfer
   138 0000001A ????????????????    <1>     .strtsc dq ?  ;Starting sector for transfer
   139 00000022 ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field if error
   140                              <1> 
   141                              <1> endstruc
   142                              <1> 
   143                              <1> struc ndInNoWaitPkt    ;Nondestructive Input No Wait Request Packet
   144                              <1>     
   145                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   146 0000000D ??                  <1>     .retbyt db ?  ;Byte read non destructively
   147                              <1> 
   148                              <1> endstruc
   149                              <1> 
   150                              <1> struc statusReqPkt   ;Status Request Packet
   151                              <1> 
   152                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   153                              <1> 
   154                              <1> endstruc
   155                              <1> 
   156                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
   157                              <1> 
   158                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   159                              <1>      
   160                              <1> endstruc
   161                              <1> 
   162                              <1> struc openReqPkt ;Open Device Request Packet
   163                              <1> 
   164                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   165                              <1>      
   166                              <1> endstruc
   167                              <1> 
   168                              <1> struc closeReqPkt ;Close Device Request Packet
   169                              <1> 
   170                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   171                              <1>      
   172                              <1> endstruc
   173                              <1> 
   174                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   175                              <1> 
   176                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   177                              <1>      
   178                              <1> endstruc
   179                              <1> 
   180                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   181                              <1> 
   182                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   183 0000000D ??                  <1>     .majfun db ?  ;Major function number
   184 0000000E ??                  <1>     .minfun db ?  ;Minor function number
   185 0000000F ????????????????    <1>     .rsival dq ?  ;Contents of RSI
   186 00000017 ????????????????    <1>     .rdival dq ?  ;Contents of RDI
   187 0000001F ????????????????    <1>     .ctlptr dq ?  ;Pointer to Generic IOCTL Request Packet
   188                              <1> 
   189                              <1> endstruc
   190                              <1> 
   191                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   192                              <1>     
   193                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   194                              <1> 
   195                              <1> endstruc
   196                              <1> 
   197                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   198                              <1>     
   199                              <1>     drvReqHdrM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   200                              <1> 
   201                              <1> endstruc
   202                              <1> 
   203                              <1> 
   204                              <1> struc genioctlGetParamsTable
   205 00000000 ??                  <1>     .size           db ?
   206 00000001 ??????????????      <1>     .res            db 7 dup (?)
   207 00000008 ????????????????    <1>     .sectorSize     db 8 dup (?)  ;Only the lower dword is valid here
   208 00000010 ????????????????    <1>     .numSectors     db 8 dup (?)
   209                              <1> endstruc
   210                              <1> 
   211                              <1> ;THE WRITE STRUCT MUST BE A STRICT SUPERSET OF THE FORMAT STRUCT ALWAYS
   212                              <1> struc genioctlLBAformat
   213 00000000 ??                  <1>     .size           db ?
   214 00000001 ??                  <1>     .numSectors     db ?  ;Number of sectors to format
   215 00000002 ????????????        <1>     .res            db 6 dup (?)
   216 00000008 ????????????????    <1>     .startSector    db 8 dup (?)  ;Sector to start format at
   217                              <1> endstruc
   218                              <1> 
   219                              <1> struc genioctlLBAwrite
   220 00000000 ??                  <1>     .size           db ?
   221 00000001 ??                  <1>     .numSectors     db ?  ;Number of sectors to write
   222 00000002 ????????????        <1>     .res            db 6 dup (?)
   223 00000008 ????????????????    <1>     .startSector    db 8 dup (?)  ;Sector to start write at
   224 00000010 ????????????????    <1>     .xferBuffer     db 8 dup (?)  ;Transfer buffer for data
   225                              <1> endstruc
     6                                  %include "./src/mcon.inc"
     1                              <1> ;MCON screen capabilities
     2                              <1> 
     3                              <1> struc mScrCap
     4 00000000 ????                <1>     .wVer       dw ?    ;Upper byte, Major num (1). Lower byte, minor num (0)
     5 00000002 ????                <1>     .wLen       dw ?    ;Length of structure (13 bytes)
     6 00000004 ??                  <1>     .bScrNum    db ?    ;Number of screens supported by driver
     7 00000005 ????????????????    <1>     .pDevHlp    dq ?    ;Pointer to the devHlp help routine
     8                              <1> endstruc
     9                              <1> 
    10                              <1> maxScr  equ 07h ;Screens 0 - 7 (so 8 screens)
    11                              <1> 
    12                              <1> DevHlp_ConsInputFilter  equ 5
    13                              <1> DevHlp_Signal_SM        equ 7
    14                              <1> DevHlp_ProcBlock        equ 9
    15                              <1> DevHlp_ProcRun          equ 10
    16                              <1> DevHlp_GetDOSVar        equ 16
    17                              <1> 
    18                              <1> 
    19                              <1> maxSib      equ maxScr + 1   
    20                              <1> maxSibSeg   equ 1   ;There is only one (empty) segment per SIB.
    21                              <1> 
    22                              <1> %macro sibM 0 ;SIB macro for expanding
    23                              <1>     .bFrozenFlg db ?    ;0 means NOT frozen!
    24                              <1>     .wOffSeg    dw ?    ;Offset from the start of the SIB to first segment
    25                              <1>     .wSegCnt    dw ?    ;Number of segments
    26                              <1>     .wSibLen    dw ?    ;Total length of the SIB
    27                              <1> %endmacro
    28                              <1> 
    29                              <1> %macro sibSegM 0    ;SIB Segment macro for expanding
    30                              <1>     .wSegSize   dw ?    ;Size of the segment. 0 = Free. Driver maintains.
    31                              <1>     .wMemFlag   dw ?    ;Clear if seg in mem. Else swapped. DOSMGR maintains.
    32                              <1>     .pMemPtr    dq ?    ;Pointer to the segment in memory. DOSMGR maintains.
    33                              <1> %endmacro
    34                              <1> 
    35                              <1> struc sib
    36                              <1>     sibM
    23 00000000 ??                  <2>  .bFrozenFlg db ?
    24 00000001 ????                <2>  .wOffSeg dw ?
    25 00000003 ????                <2>  .wSegCnt dw ?
    26 00000005 ????                <2>  .wSibLen dw ?
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc sibSeg
    40                              <1>     sibSegM
    30 00000000 ????                <2>  .wSegSize dw ?
    31 00000002 ????                <2>  .wMemFlag dw ?
    32 00000004 ????????????????    <2>  .pMemPtr dq ?
    41                              <1> endstruc
    42                              <1> 
    43                              <1> struc screenSib 
    44                              <1> ;Our screen sib has one segment only and it comes immediately after the sib
    45                              <1>     sibM
    23 00000000 ??                  <2>  .bFrozenFlg db ?
    24 00000001 ????                <2>  .wOffSeg dw ?
    25 00000003 ????                <2>  .wSegCnt dw ?
    26 00000005 ????                <2>  .wSibLen dw ?
    46                              <1>     sibSegM
    30 00000007 ????                <2>  .wSegSize dw ?
    31 00000009 ????                <2>  .wMemFlag dw ?
    32 0000000B ????????????????    <2>  .pMemPtr dq ?
    47                              <1> endstruc
     7                                  %include "./src/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1>     ret
    14                              <1> %endmacro
    15                              <1> 
    16                              <1> %macro cret 1
    17                              <1>     j%-1 short %%a
    18                              <1>     return
    19                              <1> %%a:
    20                              <1> %endmacro
    21                              <1> 
    22                              <1> %macro retz 0
    23                              <1> cret z
    24                              <1> %endmacro
    25                              <1> 
    26                              <1> %macro retnz 0
    27                              <1> cret nz
    28                              <1> %endmacro
    29                              <1> 
    30                              <1> %macro rete 0
    31                              <1> cret e
    32                              <1> %endmacro
    33                              <1> 
    34                              <1> %macro retne 0
    35                              <1> cret ne
    36                              <1> %endmacro
    37                              <1> 
    38                              <1> %macro retc 0
    39                              <1> cret c
    40                              <1> %endmacro
    41                              <1> 
    42                              <1> %macro retnc 0
    43                              <1> cret nc
    44                              <1> %endmacro
    45                              <1> 
    46                              <1> %macro retb 0
    47                              <1> cret b
    48                              <1> %endmacro
    49                              <1> 
    50                              <1> %macro retnb 0
    51                              <1> cret nb
    52                              <1> %endmacro
    53                              <1> 
    54                              <1> %macro reta 0
    55                              <1> cret a
    56                              <1> %endmacro
    57                              <1> 
    58                              <1> %macro retna 0
    59                              <1> cret na
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> %macro breakpoint 0
    63                              <1> xchg bx, bx
    64                              <1> %endmacro
     8                                  
     9                                  Segment cseg start=0 vstart=0
    10                                  %include "./src/mcdata.asm" ;Cannot put this in a separate segment due to reloc issues
     1                              <1> 
     2                              <1> ;Driver version number
     3                              <1> majVers equ 0
     4                              <1> minVers equ 2
     5                              <1> 
     6                              <1> conHdr:
     7 00000000 FFFFFFFFFFFFFFFF    <1>     dq -1
     8 00000008 7380                <1>     dw devDrvChar | devDrvIOCTL | devDrvMulti | devDrvFastOut | devDrvConOut | devDrvConIn
     9 0000000A [2B01000000000000]  <1>     dq strategy
    10 00000012 [6A01000000000000]  <1>     dq noOp    ;We don't use the interrupt endpoint.
    11 0000001A 434F4E2020202020    <1>     db "CON     "
    12                              <1> 
    13                              <1> funcTbl:
    14 00000022 2007                <1>     dw init - funcTbl       ;Init function
    15 00000024 4801                <1>     dw noOp - funcTbl       ;Media Check
    16 00000026 4801                <1>     dw noOp - funcTbl       ;Build BPB
    17 00000028 4901                <1>     dw unkCmd - funcTbl    ;IOCTL Input
    18 0000002A 5601                <1>     dw read - funcTbl       ;Read
    19 0000002C EC01                <1>     dw ndRead - funcTbl     ;Non-destructive read
    20 0000002E 4D02                <1>     dw inStatus - funcTbl   ;Input Status
    21 00000030 5A02                <1>     dw flushInBuf - funcTbl ;Input flush
    22 00000032 B002                <1>     dw write - funcTbl      ;Write
    23 00000034 B002                <1>     dw write - funcTbl      ;Write with verify
    24 00000036 4801                <1>     dw noOp - funcTbl       ;Output Status
    25 00000038 4801                <1>     dw noOp - funcTbl       ;Output Flush
    26 0000003A 4801                <1>     dw noOp - funcTbl       ;IOCTL Output
    27 0000003C 4801                <1>     dw noOp - funcTbl       ;Device Open
    28 0000003E 4801                <1>     dw noOp - funcTbl       ;Device Close
    29 00000040 4801                <1>     dw noOp - funcTbl       ;Removable Media
    30 00000042 4901                <1>     dw unkCmd - funcTbl    ;Reserved function
    31 00000044 4901                <1>     dw unkCmd - funcTbl    ;Reserved function
    32 00000046 4901                <1>     dw unkCmd - funcTbl    ;Reserved function
    33                              <1> ; New functions
    34 00000048 3103                <1>     dw ioctl - funcTbl      ;Generic IOCTL
    35                              <1> 
    36                              <1> funcTblE equ ($ - funcTbl)/2    ;Compute number of entries
    37                              <1> 
    38                              <1> ioctlTbl:
    39 0000004A 3904                <1>     dw ioctl_init - ioctlTbl   ;Init multitasking capabilities 
    40 0000004C 4103                <1>     dw ioctl_ls   - ioctlTbl   ;Locate Segment Information Block
    41 0000004E 8C03                <1>     dw ioctl_ss   - ioctlTbl   ;Save Segment
    42 00000050 A203                <1>     dw ioctl_rs   - ioctlTbl   ;Restore Segment
    43 00000052 CB03                <1>     dw ioctl_ei   - ioctlTbl   ;Enable IO
    44 00000054 E603                <1>     dw ioctl_is   - ioctlTbl   ;Initialise Screen
    45 00000056 1804                <1>     dw ioctl_strt - ioctlTbl   ;Start (continue) console output (ex driver call)
    46 00000058 2E04                <1>     dw ioctl_stop - ioctlTbl   ;Stop (freeze) console output (ex driver call)
    47 0000005A D504                <1>     dw ioctl_deinst - ioctlTbl ;Deactivate Multitasking capabilities
    48                              <1> 
    49                              <1> 
    50 0000005C 00                  <1> bConBuf     db 0    ;Single byte input buffer
    51 0000005D 00                  <1> bKeybWait   db 0    ;Set if we are waiting on Int 36h for a keystroke
    52 0000005E 00                  <1> bInMulti    db 0    ;If set, in multitasking.
    53                              <1> 
    54 0000005F 0000000000000000    <1> pOldKbdIntr dq 0    ;Ptr to the Keyboard interrupt 
    55 00000067 0000000000000000    <1> pOldKbdHdlr dq 0    ;Ptr to the Keyboard service routine
    56 0000006F [6A01000000000000]  <1> pDevHlp     dq noOp ;Ptr to the DOS session help interface. Default to NOP
    57 00000077 FFFFFFFFFFFFFFFF    <1> pScrIoOk    dq -1   ;Ptr to the DOS variable that is set if screen IO is ok
    58                              <1> 
    59                              <1> 
    60                              <1> ;Screen Vars
    61 0000007F 00                  <1> bCurScr     db 0    ;Current screen number
    62 00000080 0000000000000000    <1> pCurSib     dq 0    ;Pointer to the current screen SIB
    63 00000088 00                  <1> bSavScr     db 0    ;Set if we are in the screen saving procedure
    64                              <1> 
    65 00000089 000000000000000000- <1> sibArray    db maxSib*screenSib_size dup (0)   ;Set our screenSIB array
    65 00000092 000000000000000000- <1>
    65 0000009B 000000000000000000- <1>
    65 000000A4 000000000000000000- <1>
    65 000000AD 000000000000000000- <1>
    65 000000B6 000000000000000000- <1>
    65 000000BF 000000000000000000- <1>
    65 000000C8 000000000000000000- <1>
    65 000000D1 000000000000000000- <1>
    65 000000DA 000000000000000000- <1>
    65 000000E3 000000000000000000- <1>
    65 000000EC 000000000000000000- <1>
    65 000000F5 000000000000000000- <1>
    65 000000FE 000000000000000000- <1>
    65 00000107 000000000000000000- <1>
    65 00000110 000000000000000000- <1>
    65 00000119 0000000000000000    <1>
    66                              <1> 
    67                              <1> 
    68                              <1> myIdt:
    69 00000121 0000                <1> .limit  dw 0
    70 00000123 0000000000000000    <1> .base   dq 0
    11                                  %include "./src/mccode.asm"
     1                              <1> ;This driver is designed to work in the MDOS environment. 
     2                              <1> 
     3                              <1> strategy:
     4                              <1> ;DOS calls this function with rbx=Ptr to request header.
     5                              <1> ;Rather than saving the 
     6 0000012B 50                  <1>     push rax
     7 0000012C 53                  <1>     push rbx
     8 0000012D 51                  <1>     push rcx
     9 0000012E 52                  <1>     push rdx
    10 0000012F 56                  <1>     push rsi
    11 00000130 57                  <1>     push rdi
    12 00000131 55                  <1>     push rbp
    13 00000132 4150                <1>     push r8 ;Use r8 as the static pointer to the request packet!
    14 00000134 4989D8              <1>     mov r8, rbx 
    15 00000137 6641C740030000      <1>     mov word [r8 + drvReqHdr.status], 0    ;Ensure status clear (should be!)
    16 0000013E 410FB64002          <1>     movzx eax, byte [r8 + drvReqHdr.cmdcde]
    17 00000143 3D14000000          <1>     cmp eax, funcTblE   
    18 00000148 7321                <1>     jae short unkCmd       ;If cmdcde is past the end of the table, error!
    19 0000014A 488D1DD1FEFFFF      <1>     lea rbx, funcTbl        ;Else get pointer to function
    20 00000151 0FB71443            <1>     movzx edx, word [rbx + 2*rax]   
    21 00000155 4801D3              <1>     add rbx, rdx
    22 00000158 FFD3                <1>     call rbx        
    23                              <1> exit:
    24 0000015A 66418148030001      <1>     or word [r8 + drvReqHdr.status], drvDonStatus    ;Set done bit!
    25                              <1> .err:
    26 00000161 4158                <1>     pop r8
    27 00000163 5D                  <1>     pop rbp
    28 00000164 5F                  <1>     pop rdi
    29 00000165 5E                  <1>     pop rsi
    30 00000166 5A                  <1>     pop rdx
    31 00000167 59                  <1>     pop rcx
    32 00000168 5B                  <1>     pop rbx
    33 00000169 58                  <1>     pop rax
    34                              <1> noOp:
    35                              <1>     return
    13 0000016A C3                  <2>  ret
    36                              <1> 
    37                              <1> unkCmd:
    38 0000016B B003                <1>     mov al, drvBadCmd
    39                              <1> errorExit:
    40                              <1> ;Jump to with al=Standard Error code
    41 0000016D 66B80080            <1>     mov ax, drvErrStatus    ;Set error bit, and NOT done bit!
    42 00000171 6641894003          <1>     mov word [r8 + drvReqHdr.status], ax
    43 00000176 EBE9                <1>     jmp short exit.err
    44                              <1> 
    45                              <1> read:    ;Read Chars
    46 00000178 B005                <1>     mov al, 05h ;Bad request structure length?
    47 0000017A 4180382A            <1>     cmp byte [r8 + drvReqHdr.hdrlen], ioReqPkt_size
    48 0000017E 75ED                <1>     jne errorExit
    49 00000180 4181781600000000    <1>     cmp dword [r8 + ioReqPkt.tfrlen], 0
    50 00000188 7470                <1>     je .exit
    51 0000018A 410FB6501A          <1>     movzx edx, byte [r8 + ioReqPkt.strtsc]  ;Get the screen number
    52 0000018F 81FA07000000        <1>     cmp edx, maxScr
    53 00000195 7607                <1>     jbe .okScrnNum
    54 00000197 B80B000000          <1>     mov eax, drvReadFault
    55 0000019C EBCF                <1>     jmp short errorExit
    56                              <1> .okScrnNum:
    57 0000019E 498B780E            <1>     mov rdi, qword [r8 + ioReqPkt.bufptr]  ;Point rdi to caller buffer
    58 000001A2 31C9                <1>     xor ecx, ecx    ;Zero the char counter
    59                              <1> .readLp:
    60 000001A4 3A15D5FEFFFF        <1>     cmp dl, byte [bCurScr]
    61 000001AA 740C                <1>     je .getch   ;If the current screen is not the one requesting, freeze!
    62 000001AC E8D6030000          <1>     call getSIB ;Get the ptr to the SIB for the screen number in dl.
    63 000001B1 E8BC030000          <1>     call procBlock  ;Lock using this SIB ptr as the identifier.
    64 000001B6 EBEC                <1>     jmp short .readLp
    65                              <1> .getch:
    66 000001B8 FA                  <1>     cli
    67 000001B9 803D9CFEFFFF00      <1>     cmp byte [bConBuf], 0   ;Does the buffer contain a zero?
    68 000001C0 753D                <1>     jnz .getScCde   ;No, get the buffer value
    69                              <1> 
    70                              <1> ;Do a simulated 36h/00h call!
    71                              <1> 
    72 000001C2 4889E3              <1>     mov rbx, rsp
    73 000001C5 53                  <1>     push rbx
    74 000001C6 31DB                <1>     xor ebx, ebx
    75 000001C8 668CD3              <1>     mov bx, ss
    76 000001CB 53                  <1>     push rbx
    77 000001CC 9C                  <1>     pushfq
    78 000001CD 668CCB              <1>     mov bx, cs
    79 000001D0 53                  <1>     push rbx
    80 000001D1 31C0                <1>     xor eax, eax    ;AH = 0
    81 000001D3 FF158EFEFFFF        <1>     call qword [pOldKbdHdlr]    ;Call BIOS Int 36h AH=00h (Safe to do so!)
    82                              <1>     ;BIOS will unlikely turn on interrupts long enough to cause a problem.
    83                              <1> ;Don't do the below as this is the same as calling Int 36h directly:
    84                              <1>     ;call keybHdlr.readChar
    85                              <1> ;Instead call the original BIOS routine since if are here we have successfully  
    86                              <1> ; checked for each char that the request we are servicing is for the currently 
    87                              <1> ; active screen.
    88                              <1> 
    89                              <1>     ;xor eax, eax
    90                              <1>     ;int 36h
    91 000001D9 6685C0              <1>     test ax, ax ;If we read a null, read again!
    92 000001DC 74DA                <1>     jz .getch
    93 000001DE 663D0072            <1>     cmp ax, 7200h   ;CTRL + PrnScr? 
    94 000001E2 7502                <1>     jne .savChr
    95 000001E4 B010                <1>     mov al, 10h     ;Store ^P in al!
    96                              <1> .savChr:
    97 000001E6 AA                  <1>     stosb
    98 000001E7 84C0                <1>     test al, al ;Was the ascii code stored 0?
    99 000001E9 7506                <1>     jnz .savScCde  ;No, skip storing scancode in buffer
   100 000001EB 88256BFEFFFF        <1>     mov byte [bConBuf], ah  ;Save scancode
   101                              <1> .savScCde:
   102 000001F1 FB                  <1>     sti
   103 000001F2 FFC1                <1>     inc ecx ;Inc chars stored in buffer
   104 000001F4 413B4816            <1>     cmp ecx, dword [r8 + ioReqPkt.tfrlen]
   105 000001F8 75AA                <1>     jne .readLp
   106                              <1> .exit:
   107 000001FA 41894816            <1>     mov dword [r8 + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   108                              <1>     return
    13 000001FE C3                  <2>  ret
   109                              <1> .getScCde:
   110 000001FF 8A0557FEFFFF        <1>     mov al, byte [bConBuf]  ;Get the buffer value
   111 00000205 C60550FEFFFF00      <1>     mov byte [bConBuf], 0   ;Reset the buffer value
   112 0000020C EBD8                <1>     jmp short .savChr
   113                              <1> 
   114                              <1> ndRead:  ;Non destructive read chars
   115 0000020E B005                <1>     mov al, 05h ;Bad request structure length?
   116 00000210 4180380E            <1>     cmp byte [r8 + drvReqHdr.hdrlen], ndInNoWaitPkt_size
   117 00000214 0F8553FFFFFF        <1>     jne errorExit
   118 0000021A 410FB6501A          <1>     movzx edx, byte [r8 + ioReqPkt.strtsc]  ;Get the screen number
   119 0000021F 81FA07000000        <1>     cmp edx, maxScr
   120 00000225 760A                <1>     jbe .okScrnNum
   121 00000227 B80B000000          <1>     mov eax, drvReadFault
   122 0000022C E93CFFFFFF          <1>     jmp errorExit
   123                              <1> .okScrnNum:
   124 00000231 3A1548FEFFFF        <1>     cmp dl, byte [bCurScr]  ;If not current screen, no char available!
   125 00000237 752E                <1>     jne .noChar
   126 00000239 8A051DFEFFFF        <1>     mov al, byte [bConBuf]
   127 0000023F 84C0                <1>     test al, al ;If this is not 0, there is a char in the buffer!
   128 00000241 751F                <1>     jnz .charFnd
   129                              <1> 
   130                              <1>     ;mov rbx, rsp
   131                              <1>     ;push rbx
   132                              <1>     ;xor ebx, ebx
   133                              <1>     ;mov bx, ss
   134                              <1>     ;push rbx
   135                              <1>     ;pushfq
   136                              <1>     ;mov bx, cs
   137                              <1>     ;push rbx
   138                              <1>     ;mov eax, 0100h  ;Lookahead
   139                              <1>     ;call qword [pOldKbdHdlr]
   140 00000243 B401                <1>     mov ah, 01h         ;Get BIOS key existance status
   141 00000245 CD36                <1>     int 36h
   142                              <1> 
   143 00000247 741E                <1>     jz .noChar          ;If zero clear => no key in buffer
   144                              <1>     ;Else, Keystroke available
   145 00000249 6685C0              <1>     test ax, ax         ;If this is null, pull from the buffer
   146 0000024C 750C                <1>     jnz .notNul         
   147 0000024E 3A152BFEFFFF        <1>     cmp dl, byte [bCurScr]  ;If no longer on current screen, no char available!
   148 00000254 7511                <1>     jne .noChar
   149                              <1>     ;mov rbx, rsp
   150                              <1>     ;push rbx
   151                              <1>     ;xor ebx, ebx
   152                              <1>     ;mov bx, ss
   153                              <1>     ;push rbx
   154                              <1>     ;pushfq
   155                              <1>     ;mov bx, cs
   156                              <1>     ;push rbx
   157                              <1>     ;xor eax, eax  ;Pull char from buffer
   158                              <1>     ;call qword [pOldKbdHdlr]
   159 00000256 CD36                <1>     int 36h             ;Calls blocking getch. Pulls the null.
   160 00000258 EBB4                <1>     jmp short ndRead    ;Now go again...
   161                              <1> .notNul:
   162 0000025A 663D0072            <1>     cmp ax, 7200h   ;CTRL + PrnScr?
   163 0000025E 7502                <1>     jne .charFnd
   164 00000260 B010                <1>     mov al, 10h     ;Report ^P
   165                              <1> .charFnd:
   166 00000262 4188400D            <1>     mov byte [r8 + ndInNoWaitPkt.retbyt], al   ;Move char in al
   167                              <1>     return
    13 00000266 C3                  <2>  ret
   168                              <1> .noChar: ;No keystroke available
   169 00000267 6641C740030002      <1>     mov word [r8 + ndInNoWaitPkt.status], drvBsyStatus   ;Set busy bit
   170                              <1>     return
    13 0000026E C3                  <2>  ret
   171                              <1> 
   172                              <1> inStatus:         ;Get Input Status
   173 0000026F B005                <1>     mov al, 05h ;Bad request structure length?
   174 00000271 4180380D            <1>     cmp byte [r8 + drvReqHdr.hdrlen], statusReqPkt_size
   175 00000275 0F85F2FEFFFF        <1>     jne errorExit
   176                              <1>     return ;Exit, device ready
    13 0000027B C3                  <2>  ret
   177                              <1> 
   178                              <1> flushInBuf:   ;Flush Input Buffers
   179 0000027C B005                <1>     mov al, 05h ;Bad request structure length?
   180 0000027E 4180380D            <1>     cmp byte [r8 + drvReqHdr.hdrlen], statusReqPkt_size
   181 00000282 0F85E5FEFFFF        <1>     jne errorExit
   182 00000288 410FB6501A          <1>     movzx edx, byte [r8 + ioReqPkt.strtsc]  ;Get the screen number
   183 0000028D 81FA07000000        <1>     cmp edx, maxScr
   184 00000293 760A                <1>     jbe .okScrnNum
   185 00000295 B80B000000          <1>     mov eax, drvReadFault
   186 0000029A E9CEFEFFFF          <1>     jmp errorExit
   187                              <1> .okScrnNum:
   188 0000029F 3A15DAFDFFFF        <1>     cmp dl, byte [bCurScr]
   189 000002A5 740C                <1>     je .cleanBuf   ;If the current screen is not the one requesting, freeze!
   190                              <1> .block:
   191 000002A7 E8DB020000          <1>     call getSIB ;Get the ptr to the SIB for the screen number in dl.
   192 000002AC E8C1020000          <1>     call procBlock  ;Lock using this SIB ptr as the identifier.
   193 000002B1 EBEC                <1>     jmp short .okScrnNum
   194                              <1> .cleanBuf:
   195 000002B3 C605A2FDFFFF00      <1>     mov byte [bConBuf], 0   ;Clear buffer
   196                              <1> 
   197 000002BA B800010000          <1>     mov eax, 0100h  ;Get buffer status
   198 000002BF CD36                <1>     int 36h
   199                              <1>     retz            ;If zero clear => no more keys to read
    23                              <2> cret z
    17 000002C1 7501                <3>  j%-1 short %%a
    18                              <3>  return
    13 000002C3 C3                  <4>  ret
    19                              <3> %%a:
   200                              <1>     ;mov rbx, rsp
   201                              <1>     ;push rbx
   202                              <1>     ;xor ebx, ebx
   203                              <1>     ;mov bx, ss
   204                              <1>     ;push rbx
   205                              <1>     ;pushfq
   206                              <1>     ;mov bx, cs
   207                              <1>     ;push rbx
   208                              <1>     ;mov eax, 0100h  ;Lookahead
   209                              <1>     ;call qword [pOldKbdHdlr]    ;If ZF=ZE, no more chars!
   210                              <1>     ;retz
   211                              <1> 
   212 000002C4 3A15B5FDFFFF        <1>     cmp dl, byte [bCurScr]
   213 000002CA 75DB                <1>     jne .block
   214 000002CC 31C0                <1>     xor eax, eax
   215 000002CE CD36                <1>     int 36h ;Read key to flush from buffer
   216                              <1>     
   217                              <1>     ;mov rbx, rsp
   218                              <1>     ;push rbx
   219                              <1>     ;xor ebx, ebx
   220                              <1>     ;mov bx, ss
   221                              <1>     ;push rbx
   222                              <1>     ;pushfq
   223                              <1>     ;mov bx, cs
   224                              <1>     ;push rbx
   225                              <1>     ;xor eax, eax  ;Pull char out
   226                              <1>     ;call qword [pOldKbdHdlr]
   227                              <1> 
   228 000002D0 EBCD                <1>     jmp short .okScrnNum    ;Check if screen number still ok!
   229                              <1> 
   230                              <1> write:   ;Write Chars
   231 000002D2 B005                <1>     mov al, 05h ;Bad request structure length?
   232 000002D4 4180382A            <1>     cmp byte [r8 + drvReqHdr.hdrlen], ioReqPkt_size
   233 000002D8 0F858FFEFFFF        <1>     jne errorExit
   234 000002DE 4181781600000000    <1>     cmp dword [r8 + ioReqPkt.tfrlen], 0
   235 000002E6 745D                <1>     je .exit
   236 000002E8 410FB6501A          <1>     movzx edx, byte [r8 + ioReqPkt.strtsc]  ;Get the screen number
   237 000002ED 81FA07000000        <1>     cmp edx, maxScr
   238 000002F3 760A                <1>     jbe .okScrnNum
   239 000002F5 B80A000000          <1>     mov eax, drvWriteFault
   240 000002FA E96EFEFFFF          <1>     jmp errorExit
   241                              <1> .okScrnNum:
   242 000002FF 498B700E            <1>     mov rsi, qword [r8 + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   243 00000303 31C9                <1>     xor ecx, ecx    ;Zero the char counter
   244                              <1> .writeLp:
   245 00000305 3A1574FDFFFF        <1>     cmp dl, byte [bCurScr]
   246 0000030B 740C                <1>     je .chkScrn ;If the current screen is not the one requesting, freeze!
   247 0000030D E875020000          <1>     call getSIB ;Get the ptr to the SIB for the screen number in dl.
   248                              <1> .block:
   249 00000312 E85B020000          <1>     call procBlock  ;Lock using this SIB ptr as the identifier.
   250 00000317 EBEC                <1>     jmp short .writeLp
   251                              <1> .chkScrn:   ;Check if the screen is frozen!
   252 00000319 488B1D60FDFFFF      <1>     mov rbx, qword [pCurSib]
   253 00000320 F603FF              <1>     test byte [rbx + sib.bFrozenFlg], -1
   254 00000323 75ED                <1>     jnz .block  ;Cant output if this flag is 0! Block on the SIB ptr.
   255 00000325 F6055CFDFFFFFF      <1>     test byte [bSavScr], -1 ;If set, we are in the middle of a save!
   256 0000032C 7409                <1>     jz .outch
   257 0000032E 488D1D53FDFFFF      <1>     lea rbx, bSavScr    ;Block on the bSavScr byte
   258 00000335 EBDB                <1>     jmp short .block
   259                              <1> .outch: 
   260 00000337 AC                  <1>     lodsb   ;Get char into al, and inc rsi
   261 00000338 E80D000000          <1>     call outch ;Fast print char
   262 0000033D FFC1                <1>     inc ecx
   263 0000033F 413B4816            <1>     cmp ecx, dword [r8 + ioReqPkt.tfrlen]
   264 00000343 75C0                <1>     jne .writeLp  ;keep printing until all chars printed
   265                              <1> .exit:
   266 00000345 41894816            <1>     mov dword [r8 + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   267                              <1>     return
    13 00000349 C3                  <2>  ret
   268                              <1> outch:
   269                              <1> ;Prints the char passed in al, with 
   270 0000034A 50                  <1>     push rax
   271 0000034B 53                  <1>     push rbx
   272 0000034C B40E                <1>     mov ah, 0Eh
   273 0000034E CD30                <1>     int 30h
   274 00000350 5B                  <1>     pop rbx
   275 00000351 58                  <1>     pop rax
   276                              <1>     return
    13 00000352 C3                  <2>  ret
   277                              <1> ; -------------------- NEW IOCTL FUNCTIONS -------------------- 
   278                              <1> ioctl:
   279 00000353 80FD03              <1>     cmp ch, 03h     ;Is this a CON IOCTL request?
   280 00000356 0F850FFEFFFF        <1>     jne unkCmd
   281 0000035C 498B700F            <1>     mov rsi, qword [r8 + ioctlReqPkt.rsival]
   282 00000360 80F940              <1>     cmp cl, 40h
   283 00000363 0F8202FEFFFF        <1>     jb unkCmd
   284 00000369 80F949              <1>     cmp cl, 49h
   285 0000036C 0F83F9FDFFFF        <1>     jae unkCmd
   286 00000372 0FB6C9              <1>     movzx ecx, cl
   287 00000375 81E940000000        <1>     sub ecx, 40h     ;Get table offset
   288 0000037B 488D1DC8FCFFFF      <1>     lea rbx, ioctlTbl
   289 00000382 488B0C4B            <1>     mov rcx, qword [rbx + 2*rcx]    ;Get the offset from ioctlTbl
   290 00000386 4801CB              <1>     add rbx, rcx    ;Add to the table base address
   291 00000389 FFE3                <1>     jmp rbx ;Jump to the ptr in rbx and return to the main dispatcher!
   292                              <1> 
   293                              <1> ;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   294                              <1> ;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   295                              <1> ; NOTE FOR FUTURE! WE WILL NEED TO SAVE SOME INFORMATION IN THE DATA AREA |
   296                              <1> ; EVEN IF USING BIOS SINCE WE NEED TO ALLOW ALL SCREENS TO HAVE SEPARATE  |
   297                              <1> ; CURSOR SHAPES! AS THINGS STAND, ALL SCREENS SHARE THE SAME CURSOR SHAPE.|
   298                              <1> ;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   299                              <1> ;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
   300                              <1> 
   301                              <1> ioctl_ls:
   302                              <1> ;Locate SIB. 
   303                              <1> ;By locating the SIB, we are selecting the screen!
   304 0000038B 4881FE07000000      <1>     cmp rsi, maxScr 
   305 00000392 0F87C1010000        <1>     ja badSIBNum
   306 00000398 89F2                <1>     mov edx, esi    ;Get the screen number in al
   307 0000039A 3815DFFCFFFF        <1>     cmp byte [bCurScr], dl
   308 000003A0 7414                <1>     je .curScr
   309 000003A2 8815D7FCFFFF        <1>     mov byte [bCurScr], dl
   310 000003A8 E8DA010000          <1>     call getSIB     ;Get sib ptr in rbx for screen number in dl.
   311 000003AD 48891DCCFCFFFF      <1>     mov qword [pCurSib], rbx
   312 000003B4 EB13                <1>     jmp short .exit
   313                              <1> .curScr:
   314                              <1> ;Here we get a pointer to the segment itself, not just the SIB
   315 000003B6 C605CBFCFFFFFF      <1>     mov byte [bSavScr], -1
   316 000003BD 31C0                <1>     xor eax, eax    ;Segment to get (Segment 0, only segment!)
   317 000003BF E8E2010000          <1>     call getSibSeg  ;Get rbx -> SIB, rdi -> Segment     
   318 000003C4 31C0                <1>     xor eax, eax
   319 000003C6 668907              <1>     mov word [rdi + sibSeg.wSegSize], ax    ;We don't need a segment!
   320                              <1> .exit:
   321 000003C9 4989581F            <1>     mov qword [r8 + ioctlReqPkt.ctlptr], rbx    ;Return SIB ptr here!
   322 000003CD 49C7400F00000000    <1>     mov qword [r8 + ioctlReqPkt.rsival], 0  ;Indicate success!
   323                              <1>     return
    13 000003D5 C3                  <2>  ret
   324                              <1> 
   325                              <1> ioctl_ss:
   326                              <1> ;Save Segment of current SIB.
   327                              <1> ;Input: rsi(sil) = ZX segment number to operate on into current SIB.
   328 000003D6 4881FE01000000      <1>     cmp rsi, maxSibSeg  ;Is this equal to 1?
   329 000003DD 0F8776010000        <1>     ja badSIBNum
   330                              <1> ;Since we are saving NO data, we simply return success!
   331 000003E3 49C7400F00000000    <1>     mov qword [r8 + ioctlReqPkt.rsival], 0  ;Indicate success!
   332                              <1>     return
    13 000003EB C3                  <2>  ret
   333                              <1> 
   334                              <1> ioctl_rs:
   335                              <1> ;Restore Segment (Actually, set segment data!)
   336                              <1> ;Input: rsi(sil) = ZX segment number to operate on into current SIB.
   337                              <1> ;
   338                              <1> ;We don't per-se restore data from the SIB instead getting BIOS to do
   339                              <1> ; the screen swap for us. We change the screen number to the current 
   340                              <1> ; screen number. 
   341                              <1> ;If we send a SIB segment number of 0, we are resetting the screen.
   342                              <1> ;Else, we are simply swapping to the screen.
   343 000003EC 4881FE01000000      <1>     cmp rsi, maxSibSeg  ;Is this equal to 1?
   344 000003F3 0F8760010000        <1>     ja badSIBNum
   345                              <1> 
   346                              <1> ;Start by swapping the screen to the SIB number!
   347 000003F9 8A0580FCFFFF        <1>     mov al, byte [bCurScr]    ;Move the screen number into al
   348 000003FF B405                <1>     mov ah, 05h     ;Set active page to al 
   349 00000401 CD30                <1>     int 30h         ;Swap active page on the VGA!
   350                              <1> 
   351 00000403 85F6                <1>     test esi, esi   ;If Segment 0, reset the screen totally!
   352 00000405 7505                <1>     jnz .exit       ;Else we just wanted to swap to this screen (segment bzw.)
   353                              <1> ;Here we reset the screen!
   354 00000407 E8B3010000          <1>     call resetScreen
   355                              <1> .exit:
   356 0000040C 49C7400F00000000    <1>     mov qword [r8 + ioctlReqPkt.rsival], 0  ;Indicate success!
   357                              <1>     return
    13 00000414 C3                  <2>  ret
   358                              <1> 
   359                              <1> ioctl_ei:
   360                              <1> ;Renable IO
   361                              <1> ;Input: rsi(sil) = Zero extended screen number to operate on.
   362 00000415 C6056CFCFFFF00      <1>     mov byte [bSavScr], 0   ;We are done saving the screen!
   363 0000041C 488D1D65FCFFFF      <1>     lea rbx, bSavScr    ;Thaw threads frozen during screen save!
   364 00000423 E83A010000          <1>     call procRun
   365 00000428 488B1D51FCFFFF      <1>     mov rbx, qword [pCurSib]    ;Thaw threads frozen while CurSib not current
   366                              <1>     return
    13 0000042F C3                  <2>  ret
   367                              <1> 
   368                              <1> ioctl_is:
   369                              <1> ;Initialise screen
   370                              <1> ;Input: rsi(sil) = Zero extended screen number to operate on.
   371 00000430 4881FE07000000      <1>     cmp rsi, maxScr 
   372 00000437 0F871C010000        <1>     ja badSIBNum
   373 0000043D 89F2                <1>     mov edx, esi
   374 0000043F 88153AFCFFFF        <1>     mov byte [bCurScr], dl
   375 00000445 E83D010000          <1>     call getSIB ;Get ptr to this sib in rdi
   376 0000044A 48893D2FFCFFFF      <1>     mov qword [pCurSib], rdi
   377 00000451 C60700              <1>     mov byte [rdi + sib.bFrozenFlg], 0  ;Screen not frozen!
   378                              <1> ;Reset the screen now
   379 00000454 E866010000          <1>     call resetScreen
   380 00000459 49C7400F00000000    <1>     mov qword [r8 + ioctlReqPkt.rsival], 0  ;Indicate success!
   381                              <1>     return
    13 00000461 C3                  <2>  ret
   382                              <1> 
   383                              <1> ioctl_strt:
   384                              <1> ;Start (continue) screen output
   385                              <1> ;Input: rsi(sil) = Zero extended screen number to operate on.
   386 00000462 488B1D17FCFFFF      <1>     mov rbx, qword [pCurSib]
   387 00000469 F603FF              <1>     test byte [rbx + sib.bFrozenFlg], -1 ;Set the freeze flag in SIB
   388                              <1>     retz    ;If the current screen is already thawed, just return!
    23                              <2> cret z
    17 0000046C 7501                <3>  j%-1 short %%a
    18                              <3>  return
    13 0000046E C3                  <4>  ret
    19                              <3> %%a:
   389 0000046F C60300              <1>     mov byte [rbx + sib.bFrozenFlg], 0  ;Thaw this SIB now
   390 00000472 E8EB000000          <1>     call procRun    ;And thaw any threads blocked on this SIB!
   391                              <1>     return
    13 00000477 C3                  <2>  ret
   392                              <1> 
   393                              <1> ioctl_stop:
   394                              <1> ;Stop (freeze) current screen output
   395                              <1> ;Input: rsi(sil) = Zero extended screen number to operate on.
   396 00000478 488B1D01FCFFFF      <1>     mov rbx, qword [pCurSib]
   397 0000047F C603FF              <1>     mov byte [rbx + sib.bFrozenFlg], -1 ;Set the freeze flag in SIB
   398                              <1>     return
    13 00000482 C3                  <2>  ret
   399                              <1> 
   400                              <1> ioctl_init:
   401                              <1> ;Multitasking initialisation function. Passes a datapkt ptr
   402                              <1> ; in ctlptr field.
   403 00000483 F605D4FBFFFFFF      <1>     test byte [bInMulti], -1 ;Have we already run this function?
   404 0000048A 0F84DBFCFFFF        <1>     je unkCmd
   405 00000490 498B501F            <1>     mov rdx, qword [r8 + ioctlReqPkt.ctlptr]    ;Get pktptr
   406 00000494 66813A0001          <1>     cmp word [rdx + mScrCap.wVer], 0100h
   407 00000499 0F85CCFCFFFF        <1>     jne unkCmd
   408 0000049F 66817A020D00        <1>     cmp word [rdx + mScrCap.wLen], mScrCap_size
   409 000004A5 0F85C0FCFFFF        <1>     jne unkCmd
   410                              <1> ;Here we have verified we are ok! Proceed.
   411 000004AB C605ACFBFFFFFF      <1>     mov byte [bInMulti], -1     ;Now we are entering MT! Set the lock!
   412                              <1> 
   413                              <1> ;This IOCTL is equivalent to how in MTDOS, CON reports caps during drvinit.
   414 000004B2 C6420408            <1>     mov byte [rdx + mScrCap.bScrNum], (maxScr + 1)
   415 000004B6 488B4205            <1>     mov rax, qword [rdx + mScrCap.pDevHlp]  ;Get the devHlp pointer
   416 000004BA 488905AEFBFFFF      <1>     mov qword [pDevHlp], rax
   417                              <1> 
   418                              <1> ;Now setup the pointer to the DOSMGR ScrIoOk byte
   419 000004C1 31C0                <1>     xor eax, eax    ;Get var 0 (ScrIoOk)
   420 000004C3 B901000000          <1>     mov ecx, 1      ;Length 1
   421 000004C8 BA10000000          <1>     mov edx, DevHlp_GetDOSVar     ;Get ScrIoOk Var
   422 000004CD FF159CFBFFFF        <1>     call qword [pDevHlp]
   423 000004D3 4889059DFBFFFF      <1>     mov qword [pScrIoOk], rax   ;Store the pointer now!
   424                              <1> 
   425                              <1> ;Now install the multitasking keyboard interrupt routines!
   426                              <1> ;DO IRQ1
   427 000004DA B8F1000000          <1>     mov eax, 0F1h   ;Get IRQ1 handler in rbx
   428 000004DF E854020000          <1>     call getIntHdlr
   429 000004E4 48891D74FBFFFF      <1>     mov qword [pOldKbdIntr], rbx
   430 000004EB 488D152B010000      <1>     lea rdx, keybIntr
   431 000004F2 B8F1000000          <1>     mov eax, 0F1h
   432 000004F7 E812020000          <1>     call installInterrupt
   433                              <1> ;DO Int 36h
   434 000004FC B836000000          <1>     mov eax, 036h   ;Get Int 36h handler in rbx
   435 00000501 E832020000          <1>     call getIntHdlr
   436 00000506 48891D5AFBFFFF      <1>     mov qword [pOldKbdHdlr], rbx
   437 0000050D 488D1587010000      <1>     lea rdx, keybHdlr
   438 00000514 B836000000          <1>     mov eax, 036h
   439 00000519 E8F0010000          <1>     call installInterrupt
   440                              <1>     return
    13 0000051E C3                  <2>  ret
   441                              <1> 
   442                              <1> ioctl_deinst:
   443                              <1> ;Reset the internal vars to set CON back to single tasking mode!
   444 0000051F FA                  <1>     cli
   445 00000520 488B1538FBFFFF      <1>     mov rdx, qword [pOldKbdIntr]
   446 00000527 B8F1000000          <1>     mov eax, 0F1h
   447 0000052C E8DD010000          <1>     call installInterrupt
   448 00000531 488B152FFBFFFF      <1>     mov rdx, qword [pOldKbdHdlr]
   449 00000538 B836000000          <1>     mov eax, 036h
   450 0000053D E8CC010000          <1>     call installInterrupt
   451 00000542 488D0521FCFFFF      <1>     lea rax, noOp
   452 00000549 4889051FFBFFFF      <1>     mov qword [pDevHlp], rax    ;Restore the do nothing function!
   453 00000550 FB                  <1>     sti
   454 00000551 C60506FBFFFF00      <1>     mov byte [bInMulti], 0  ;Back out of Multitasking
   455                              <1>     return
    13 00000558 C3                  <2>  ret
   456                              <1> 
   457                              <1> badSIBNum:
   458                              <1> ;Jumped to to indicate a bad SIB or segment number!
   459 00000559 49C7400F01000000    <1>     mov qword [r8 + ioctlReqPkt.rsival], 1 
   460                              <1>     return
    13 00000561 C3                  <2>  ret
   461                              <1> 
   462                              <1> procRun:
   463                              <1> ;Input: rbx = qword identifier for the block tasks to unblock.
   464 00000562 53                  <1>     push rbx
   465 00000563 52                  <1>     push rdx
   466 00000564 BA0A000000          <1>     mov edx, DevHlp_ProcRun
   467 00000569 FF1500FBFFFF        <1>     call qword [pDevHlp]
   468 0000056F 5A                  <1>     pop rdx
   469 00000570 5B                  <1>     pop rbx
   470                              <1>     return
    13 00000571 C3                  <2>  ret
   471                              <1> 
   472                              <1> procBlock:
   473                              <1> ;Input: rbx = qword identifier to block the thread on.
   474 00000572 53                  <1>     push rbx
   475 00000573 51                  <1>     push rcx
   476 00000574 52                  <1>     push rdx
   477 00000575 BA09000000          <1>     mov edx, DevHlp_ProcBlock   ;ProcBlock, Sleep is not interruptable
   478 0000057A 31C9                <1>     xor ecx, ecx    ;No timeout!
   479 0000057C FA                  <1>     cli         ;Stop Interrupts to prevent race conditions
   480 0000057D FF15ECFAFFFF        <1>     call qword [pDevHlp]
   481 00000583 5A                  <1>     pop rdx
   482 00000584 59                  <1>     pop rcx
   483 00000585 5B                  <1>     pop rbx
   484                              <1>     return
    13 00000586 C3                  <2>  ret
   485                              <1> 
   486                              <1> ;----------------------------------------------------------
   487                              <1> ; Internal utility functions
   488                              <1> ;----------------------------------------------------------
   489                              <1> 
   490                              <1> getSIB:
   491                              <1> ;Input: edx (zx from dl) = Screen number to get SIB for
   492                              <1> ;Output: rbx -> SIB for that screen number
   493 00000587 488D1DFBFAFFFF      <1>     lea rbx, sibArray
   494 0000058E 85D2                <1>     test edx, edx
   495                              <1>     retz
    23                              <2> cret z
    17 00000590 7501                <3>  j%-1 short %%a
    18                              <3>  return
    13 00000592 C3                  <4>  ret
    19                              <3> %%a:
   496 00000593 50                  <1>     push rax
   497 00000594 51                  <1>     push rcx
   498 00000595 52                  <1>     push rdx
   499 00000596 89D0                <1>     mov eax, edx
   500 00000598 B913000000          <1>     mov ecx, screenSib_size ;Get screen Sib size
   501 0000059D F7E1                <1>     mul ecx ;eax <- eax*ecx
   502 0000059F 4801C3              <1>     add rbx, rax
   503 000005A2 5A                  <1>     pop rdx
   504 000005A3 59                  <1>     pop rcx
   505 000005A4 58                  <1>     pop rax
   506                              <1>     return
    13 000005A5 C3                  <2>  ret
   507                              <1> 
   508                              <1> getSibSeg:
   509                              <1> ;Get the chosen segment from the current SIB
   510                              <1> ;Input: eax (zx from ax) = Segment number to get
   511                              <1> ;Output: rbx -> Current SIB
   512                              <1> ;        rdi -> Chosen SIB segment
   513 000005A6 488B1DD3FAFFFF      <1>     mov rbx, qword [pCurSib]
   514 000005AD BF0C000000          <1>     mov edi, sibSeg_size ;Get the size of the sibseg
   515 000005B2 F7E7                <1>     mul edi     ;Get the segment offset in the segment block in eax
   516 000005B4 0FB77B01            <1>     movzx edi, word [rbx + sib.wOffSeg] ;
   517 000005B8 4801C7              <1>     add rdi, rax    ;Turn into an offset into the SIB
   518 000005BB 4801DF              <1>     add rdi, rbx    ;Turn into a proper pointer
   519                              <1>     return
    13 000005BE C3                  <2>  ret
   520                              <1> 
   521                              <1> 
   522                              <1> resetScreen:
   523                              <1> ;Resets the current screen (Blanks).
   524 000005BF 0FB61DB9FAFFFF      <1>     movzx ebx, byte [bCurScr]    ;Move the screen number into ebx
   525 000005C6 53                  <1>     push rbx    ;Save the screen number on stack
   526 000005C7 0FB6D4              <1>     movzx edx, ah   ;Get number of columns in dl
   527 000005CA FECA                <1>     dec dl
   528 000005CC B619                <1>     mov dh, 25  ;Number of rows is standard
   529 000005CE 31C0                <1>     xor eax, eax
   530 000005D0 89C1                <1>     mov ecx, eax
   531 000005D2 B707                <1>     mov bh, 7   ;Screen attributes
   532 000005D4 B406                <1>     mov ah, 6   ;Scroll
   533 000005D6 CD30                <1>     int 30h
   534                              <1> 
   535 000005D8 31D2                <1>     xor edx, edx    ;Set cursor coordinates to top left of screen
   536 000005DA 5B                  <1>     pop rbx     ;Get back the screen number
   537 000005DB B402                <1>     mov ah, 2   ;Set cursor position!
   538 000005DD CD30                <1>     int 30h
   539                              <1>     return
    13 000005DF C3                  <2>  ret
   540                              <1> ;--------------------------------------------------------------
   541                              <1> ;------------- Driver built-in Interrupt Routines -------------
   542                              <1> ;--------------------------------------------------------------
   543                              <1> fastOutput:         ;This CON driver supports Int 29h
   544                              <1> ;Called with char to transfer in al
   545 000005E0 E865FDFFFF          <1>     call outch
   546 000005E5 48CF                <1>     iretq
   547                              <1> 
   548                              <1> ctrlBreak:
   549                              <1> ;CON Int 3Bh handler to detect CTRL+BREAK.
   550 000005E7 50                  <1>     push rax
   551 000005E8 52                  <1>     push rdx
   552                              <1> ;Simulate an interrupt call to the BIOS to pull the key out
   553                              <1> ; from the buffer.
   554 000005E9 4889E2              <1>     mov rdx, rsp
   555 000005EC 31C0                <1>     xor eax, eax
   556 000005EE 668CD0              <1>     mov ax, ss
   557 000005F1 50                  <1>     push rax
   558 000005F2 52                  <1>     push rdx
   559 000005F3 9C                  <1>     pushfq
   560 000005F4 668CC8              <1>     mov ax, cs
   561 000005F7 50                  <1>     push rax
   562 000005F8 31C0                <1>     xor eax, eax    ;Getch, BIOS Places a zero word in the keyboard buffer
   563 000005FA FF1567FAFFFF        <1>     call qword [pOldKbdHdlr]    ;Pull the zero word out of the keyb buffer
   564 00000600 B803000000          <1>     mov eax, 03h                ;Replace it with a ^C char
   565 00000605 BA05000000          <1>     mov edx, DevHlp_ConsInputFilter
   566 0000060A FF155FFAFFFF        <1>     call qword [pDevHlp]        ;Ask DOS if it wants to eat the ^C
   567 00000610 7407                <1>     jz .exit                    ;Jump if DOS ate ^C :(
   568 00000612 C60543FAFFFF03      <1>     mov byte [bConBuf], 03h     ;Place a ^C in buffer
   569                              <1> .exit:
   570 00000619 5A                  <1>     pop rdx
   571 0000061A 58                  <1>     pop rax
   572 0000061B 48CF                <1>     iretq
   573                              <1> 
   574                              <1> keybIntr:        ;New Keyboard Interrupt Hdlr
   575 0000061D 50                  <1>     push rax        ;Save RAX as a trashed reg
   576 0000061E 52                  <1>     push rdx
   577                              <1> ;Simulate an IRQ entry to old kbdHldr
   578 0000061F 4889E2              <1>     mov rdx, rsp
   579 00000622 31C0                <1>     xor eax, eax
   580 00000624 668CD0              <1>     mov ax, ss
   581 00000627 50                  <1>     push rax
   582 00000628 52                  <1>     push rdx
   583 00000629 9C                  <1>     pushfq
   584 0000062A 668CC8              <1>     mov ax, cs
   585 0000062D 50                  <1>     push rax
   586 0000062E FF152BFAFFFF        <1>     call qword [pOldKbdIntr]    ;Do the SCP/BIOS kbd handler code!
   587                              <1> 
   588 00000634 4889E2              <1>     mov rdx, rsp
   589 00000637 31C0                <1>     xor eax, eax
   590 00000639 668CD0              <1>     mov ax, ss
   591 0000063C 50                  <1>     push rax
   592 0000063D 52                  <1>     push rdx
   593 0000063E 9C                  <1>     pushfq
   594 0000063F 668CC8              <1>     mov ax, cs
   595 00000642 50                  <1>     push rax
   596 00000643 B800010000          <1>     mov eax, 0100h              ;Now read ahead, under our handler
   597 00000648 FF1519FAFFFF        <1>     call qword [pOldKbdHdlr]    ;Gets the SC/ASCII pair in ax
   598 0000064E BA05000000          <1>     mov edx, DevHlp_ConsInputFilter
   599 00000653 FF1516FAFFFF        <1>     call qword [pDevHlp]
   600 00000659 7519                <1>     jnz .keepChar
   601                              <1>     ;Else remove the char from the buffer
   602 0000065B 4889E2              <1>     mov rdx, rsp
   603 0000065E 31C0                <1>     xor eax, eax
   604 00000660 668CD0              <1>     mov ax, ss
   605 00000663 50                  <1>     push rax
   606 00000664 52                  <1>     push rdx
   607 00000665 9C                  <1>     pushfq
   608 00000666 668CC8              <1>     mov ax, cs
   609 00000669 50                  <1>     push rax
   610 0000066A 31C0                <1>     xor eax, eax
   611 0000066C FF15F5F9FFFF        <1>     call qword [pOldKbdHdlr]    ;Gets the SC/ASCII pair in ax
   612 00000672 EB23                <1>     jmp short .exit
   613                              <1> .keepChar:
   614 00000674 FA                  <1>     cli
   615 00000675 F605E1F9FFFFFF      <1>     test byte [bKeybWait], -1  
   616 0000067C 7419                <1>     jz .exit
   617 0000067E 53                  <1>     push rbx
   618 0000067F 51                  <1>     push rcx
   619 00000680 488D1DD6F9FFFF      <1>     lea rbx, bKeybWait  ;Run all processes with this identifier
   620 00000687 C60300              <1>     mov byte [rbx], 0   ;Clear the flag first
   621 0000068A BA0A000000          <1>     mov edx, DevHlp_ProcRun  ;ProcRun
   622 0000068F FF15DAF9FFFF        <1>     call qword [pDevHlp]
   623 00000695 59                  <1>     pop rcx
   624 00000696 5B                  <1>     pop rbx
   625                              <1> .exit:
   626 00000697 5A                  <1>     pop rdx
   627 00000698 58                  <1>     pop rax
   628 00000699 48CF                <1>     iretq
   629                              <1> 
   630                              <1> 
   631                              <1> keybHdlr:   ;Int 36h
   632 0000069B 84E4                <1>     test ah, ah
   633 0000069D 740B                <1>     je .readChar
   634 0000069F 80FC01              <1>     cmp ah, 1
   635 000006A2 7455                <1>     je .lookahead
   636 000006A4 FF25BDF9FFFF        <1>     jmp qword [pOldKbdHdlr]
   637                              <1> .readChar:
   638 000006AA 50                  <1>     push rax    ;Push original function number on the stack
   639 000006AB 53                  <1>     push rbx
   640 000006AC 51                  <1>     push rcx
   641 000006AD 52                  <1>     push rdx
   642                              <1> .readChLp:
   643 000006AE 488B1DC2F9FFFF      <1>     mov rbx, qword [pScrIoOk]
   644 000006B5 F603FF              <1>     test byte [rbx], -1
   645 000006B8 7507                <1>     jnz .okToRead
   646 000006BA E8B3FEFFFF          <1>     call procBlock
   647 000006BF EBED                <1>     jmp short .readChLp ;Check again!
   648                              <1> .okToRead:
   649                              <1> ;Now we simulate a call into 36h/AH=01h - Get keyboard buffer status
   650 000006C1 FA                  <1>     cli
   651 000006C2 4889E2              <1>     mov rdx, rsp
   652 000006C5 31C0                <1>     xor eax, eax
   653 000006C7 668CD0              <1>     mov ax, ss
   654 000006CA 50                  <1>     push rax
   655 000006CB 52                  <1>     push rdx
   656 000006CC 9C                  <1>     pushfq
   657 000006CD 668CC8              <1>     mov ax, cs
   658 000006D0 50                  <1>     push rax
   659 000006D1 B800010000          <1>     mov eax, 0100h  ;Get the keyb status
   660 000006D6 FF158BF9FFFF        <1>     call qword [pOldKbdHdlr]    ;Interrupts remain set on return
   661 000006DC 7511                <1>     jnz .doCharRead
   662                              <1> ;If the char isn't there, we gotta pblock until it is.
   663 000006DE 488D1D78F9FFFF      <1>     lea rbx, bKeybWait
   664 000006E5 C603FF              <1>     mov byte [rbx], -1
   665 000006E8 E885FEFFFF          <1>     call procBlock
   666 000006ED EBBF                <1>     jmp short .readChLp ;Check again with CLI set!
   667                              <1> .doCharRead:
   668 000006EF 5A                  <1>     pop rdx
   669 000006F0 59                  <1>     pop rcx
   670 000006F1 5B                  <1>     pop rbx
   671 000006F2 58                  <1>     pop rax
   672                              <1> .goKbd:
   673 000006F3 FF256EF9FFFF        <1>     jmp qword [pOldKbdHdlr]
   674                              <1> .lookahead:
   675 000006F9 53                  <1>     push rbx
   676 000006FA 488B1D76F9FFFF      <1>     mov rbx, qword [pScrIoOk]   ;Can we check?
   677 00000701 F603FF              <1>     test byte [rbx], -1
   678 00000704 5B                  <1>     pop rbx
   679 00000705 75EC                <1>     jnz .goKbd  ;If we can, do it!
   680 00000707 80642410BF          <1>     and byte [rsp + 2*8], ~40h    ;Clear ZF of flags
   681 0000070C 48CF                <1>     iretq
   682                              <1> 
   683                              <1> installInterrupt:
   684                              <1> ;Writes the interrupt in the right place in the table
   685                              <1>     ;al = Interrupt number
   686                              <1>     ;rdx -> Handler to install
   687 0000070E 0F010D0CFAFFFF      <1>     sidt [myIdt]
   688 00000715 0FB6C0              <1>     movzx eax, al
   689 00000718 4892                <1>     xchg rdx, rax
   690 0000071A 48C1E204            <1>     shl rdx, 4h     ;Multiply IDT entry number by 16
   691 0000071E 480315FEF9FFFF      <1>     add rdx, qword [myIdt.base]    
   692 00000725 668902              <1>     mov word [rdx], ax  ;Get low word into offset 15...0
   693 00000728 48C1E810            <1>     shr rax, 10h    ;Bring next word low
   694 0000072C 66894206            <1>     mov word [rdx + 6], ax  ;Get low word into offset 31...16
   695 00000730 48C1E810            <1>     shr rax, 10h    ;Bring last dword low
   696 00000734 894208              <1>     mov dword [rdx + 8], eax
   697 00000737 C3                  <1>     ret
   698                              <1> getIntHdlr:
   699                              <1> ;Gets an interrupt value. 
   700                              <1> ;Input: al = Interrupt number
   701                              <1> ;Output: rbx = Interrupt Vector
   702 00000738 50                  <1>     push rax
   703 00000739 B802120000          <1>     mov eax, 1202h  ;Get Interrupt handler in rbx
   704 0000073E CD2F                <1>     int 2Fh
   705 00000740 58                  <1>     pop rax
   706                              <1>     return
    13 00000741 C3                  <2>  ret
   707                              <1>     ;sidt [myIdt]
   708                              <1>     ;movzx eax, al
   709                              <1>     ;shl rax, 4h     ;Multiply IDT entry number by 16 (Size of IDT entry)
   710                              <1>     ;add rax, qword [myIdt.base]    
   711                              <1>     ;xor ebx, ebx
   712                              <1>     ;mov ebx, dword [rax + 8]    ;Get bits 63...32
   713                              <1>     ;shl rbx, 10h    ;Push the high dword high
   714                              <1>     ;mov bx, word [rax + 6]      ;Get bits 31...16
   715                              <1>     ;shl rbx, 10h    ;Push word 2 into posiiton
   716                              <1>     ;mov bx, word [rax]          ;Get bits 15...0
   717                              <1>     ;return
   718                              <1> 
   719                              <1> ;------------------ EJECT POINT ------------------
   720                              <1> 
   721                              <1> init:
   722                              <1> ;Start by hooking int 3Bh, int 29h and 0F1h (IRQ1) as part of the CON driver
   723                              <1> ;DO FASTOUT
   724 00000742 488D1597FEFFFF      <1>     lea rdx, fastOutput
   725 00000749 B829000000          <1>     mov eax, 29h
   726 0000074E E8BBFFFFFF          <1>     call installInterrupt
   727                              <1> ;DO CTRL+BREAK
   728 00000753 488D158DFEFFFF      <1>     lea rdx, ctrlBreak
   729 0000075A B83B000000          <1>     mov eax, 3Bh
   730 0000075F E8AAFFFFFF          <1>     call installInterrupt
   731                              <1> .ci0:
   732 00000764 B401                <1>     mov ah, 01      ;Get buffer status
   733 00000766 CD36                <1>     int 36h
   734 00000768 7406                <1>     jz .ci1      ;If zero clear => no more keys to read
   735 0000076A 30E4                <1>     xor ah, ah
   736 0000076C CD36                <1>     int 36h ;Read key to flush from buffer
   737 0000076E EBF4                <1>     jmp short .ci0
   738                              <1> .ci1:
   739 00000770 B800050000          <1>     mov eax, 0500h  ;Set page zero as the default page
   740 00000775 CD30                <1>     int 30h
   741 00000777 B402                <1>     mov ah, 02h
   742 00000779 31D2                <1>     xor edx, edx    ;Set screen cursor to top right corner
   743 0000077B 88D7                <1>     mov bh, dl      ;Set cursor for page 0
   744 0000077D CD30                <1>     int 30h
   745 0000077F B707                <1>     mov bh, 07h     ;Grey/Black attribs
   746 00000781 B800060000          <1>     mov eax, 0600h  ;Clear whole screen
   747 00000786 CD30                <1>     int 30h
   748                              <1> 
   749 00000788 B800510000          <1>     mov eax, 5100h
   750 0000078D CD21                <1>     int 21h             ;Get current PSP ptr
   751 0000078F 4881FB09000000      <1>     cmp rbx, 9          ;If we are being used as a Kernel driver, no msg!
   752 00000796 740E                <1>     je skipMsg
   753                              <1> ;Else, print message!
   754 00000798 488D1513000000      <1>     lea rdx, helloStr   ;Print install string
   755 0000079F B800090000          <1>     mov eax, 0900h
   756 000007A4 CD21                <1>     int 21h
   757                              <1> skipMsg:
   758 000007A6 488D0595FFFFFF      <1>     lea rax, init   ;Eject init
   759 000007AD 4989400E            <1>     mov qword [r8 + initReqPkt.endptr], rax
   760                              <1>     return
    13 000007B1 C3                  <2>  ret
   761                              <1> 
   762 000007B2 2D2D2D20496E737461- <1> helloStr    db  "--- Installing MCON Device Driver V"
   762 000007BB 6C6C696E67204D434F- <1>
   762 000007C4 4E2044657669636520- <1>
   762 000007CD 4472697665722056    <1>
   763 000007D5 302E30              <1>             db  majVers+"0",".",minVers/10+"0"
   764 000007D8 32202D2D2D0A0D24    <1>             db (minVers-minVers/10*10)+"0", " ---", 10,13,"$"
   764          ------------------  <1>  info: assembly required 1+2+2 passes

