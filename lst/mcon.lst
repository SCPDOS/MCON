     1                                  [map all ./lst/mcon.map]
     2                                  DEFAULT REL
     3                                  BITS 64
     4                                  
     5                                  %include "./src/drvStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     4                              <1> ; device driver related structures.                     ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> struc drvHdr  ;Device Driver Header for character and block devices
     8                              <1> 
     9 00000000 ????????????????    <1>     .nxtPtr dq ?  ;Pointer to the next driver header, -1 if at the end
    10 00000008 ????                <1>     .attrib dw ?  ;Attribute Word
    11 0000000A ????????????????    <1>     .strPtr dq ?  ;Strategy Entry Pointer
    12 00000012 ????????????????    <1>     .intPtr dq ?  ;Interrupt Entry Pointer
    13                              <1>     .drvUnt:        ;Number of units pointer
    14 0000001A ????????????????    <1>     .drvNam db 8 dup (?)  ;Driver name (Char) or Number of units byte (Block)
    15                              <1> 
    16                              <1> endstruc
    17                              <1> 
    18                              <1> ;Command Code equates
    19                              <1>     drvINIT         equ 0
    20                              <1>     drvMEDCHK       equ 1
    21                              <1>     drvBUILDBPB     equ 2
    22                              <1>     drvIOCTLREAD    equ 3
    23                              <1>     drvREAD         equ 4
    24                              <1>     drvNONDESTREAD  equ 5
    25                              <1>     drvINSTATUS     equ 6
    26                              <1>     drvFLUSHINBUF   equ 7
    27                              <1>     drvWRITE        equ 8
    28                              <1>     drvWRITEVERIFY  equ 9
    29                              <1>     drvOUTSTATUS    equ 10
    30                              <1>     drvFLUSHOUTBUF  equ 11
    31                              <1>     drvIOCTLWRITE   equ 12
    32                              <1>     drvOPEN         equ 13
    33                              <1>     drvCLOSE        equ 14
    34                              <1>     drvREMMEDCHECK  equ 15
    35                              <1>     drvOUTTILBUSY   equ 16  ;Not implemented
    36                              <1>     drvIOCTL        equ 19
    37                              <1>     drvStopCon      equ 20  ; NEW MULTITASKING 
    38                              <1>     drvRestartCon   equ 21  ; NEW MULTITASKING
    39                              <1>     drvGETDRVMAP    equ 23
    40                              <1>     drvSETDRVMAP    equ 24
    41                              <1>     
    42                              <1> ;Driver Error equates 
    43                              <1>     drvWPErr        equ 0   ;Write Protect Violation
    44                              <1>     drvBadUnit      equ 1   ;Unknown unit
    45                              <1>     drvNotReady     equ 2   ;Device not ready
    46                              <1>     drvBadCmd       equ 3   ;Unknown command
    47                              <1>     drvCRCErr       equ 4   ;CRC Error
    48                              <1>     drvBadDrvReq    equ 5   ;Bad drive request structure length
    49                              <1>     drvBadSeek      equ 6   ;Seek error
    50                              <1>     drvBadMed       equ 7   ;Unknown media
    51                              <1>     drvSecNotFnd    equ 8   ;Sector not found
    52                              <1>     drvNoPaper      equ 9   ;Printer out of paper
    53                              <1>     drvWriteFault   equ 10  ;Write Fault
    54                              <1>     drvReadFault    equ 11  ;Read Fault
    55                              <1>     drvGenFault     equ 12  ;General Fault
    56                              <1>     drvBadDskChnge  equ 15  ;Invalid disk change
    57                              <1> 
    58                              <1> ;Driver status word status bit meanings
    59                              <1>     drvErrStatus    equ 8000h  
    60                              <1>     drvDonStatus    equ 0100h
    61                              <1>     drvBsyStatus    equ 0200h
    62                              <1> 
    63                              <1> ;Driver Attribute Word bit meanings
    64                              <1>     devDrvConIn    equ 1h  ;If set, device is CON input
    65                              <1>     devDrvConOut   equ 2h  ;If set, device is CON output
    66                              <1>     devDrvNulDev   equ 4h  ;If set, device is NULL device
    67                              <1>     devDrvClockDev equ 8h  ;If set, device is CLOCK device
    68                              <1>     devDrvFastOut  equ 10h ;If set, device supports Int 29h
    69                              <1>     devDrvMulti    equ 20h ;Reserved, If set, device is multitasking. 
    70                              <1>     devDrvIOCTL    equ 40h ;If set, IOCTL and GET/SET suported
    71                              <1>     devDrvHdlCTL   equ 800h ;If set, Open, Close and Rem media supported
    72                              <1>     devDrvIOCTLRW  equ 4000h ;If set, IOCTL Read/Write supported
    73                              <1>     devDrvChar     equ 8000h ;If set, Char device
    74                              <1> ;Bit 0 1=console input
    75                              <1> ;    1 1=console output (character devices)
    76                              <1> ;    2 1=NUL device
    77                              <1> ;    3 1=CLOCK device
    78                              <1> ;    4 1=Int 29 output (CON)
    79                              <1> ;    5 1=Multitasking driver. Bit ignored by DOS. Used by multitaskers.
    80                              <1> ; If bit set, no crit2 lock placed on thread when making drv request.
    81                              <1> ;    6 1=extended functions supported (13,17,18) (3.2+)
    82                              <1> ;    7 1=Generic IOCTL function supported (19)
    83                              <1> ;   11 1=open/close/removable media supported (3.0+)
    84                              <1> ;   13 1=output until busy supported (character devices) (3.0+)
    85                              <1> ;      1=media descriptor in FAT required (block devices)
    86                              <1> ;   14 1=IOCTL R/W supported
    87                              <1> ;   15 0=block device
    88                              <1> ;      1=character device
    89                              <1> 
    90                              <1> ;Driver structures
    91                              <1> 
    92                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    93                              <1> 
    94                              <1>     .hdrlen db ?  ;Length of the request header
    95                              <1>     .unitnm db ?  ;Unit number, meaningless for character devs
    96                              <1>     .cmdcde db ?  ;Command code
    97                              <1>     .status dw ?  ;Status word
    98                              <1>     .devptr dq ?  ;Device queue pointer field, reserved for future use
    99                              <1> 
   100                              <1> %endmacro
   101                              <1> 
   102                              <1> struc drvReqHdr
   103                              <1>     drvReqHdrM
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   104                              <1> endstruc
   105                              <1> 
   106                              <1> struc initReqPkt  ;Init Request Packet
   107                              <1> 
   108                              <1>     drvReqHdrM   ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   109 0000000D ??                  <1>     .numunt db ?  ;Number of logical units (Block only, 0 for char)
   110 0000000E ????????????????    <1>     .endptr dq ?  ;Pointer to first free byte after driver
   111 00000016 ????????????????    <1>     .optptr dq ?  ;Ptr to BPB array (blkdev) or cmdline args
   112 0000001E ??                  <1>     .drvnum db ?  ;First Drive number
   113                              <1> 
   114                              <1> endstruc
   115                              <1> 
   116                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
   117                              <1> 
   118                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   119 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   120 0000000E ??                  <1>     .medret db ?  ;Return byte (Has media been changed?)
   121 0000000F ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field
   122                              <1> 
   123                              <1> endstruc
   124                              <1> 
   125                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
   126                              <1> 
   127                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   128 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   129 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   130 00000016 ????????????????    <1>     .bpbptr dq ?  ;Pointer to the BPB
   131                              <1> 
   132                              <1> endstruc
   133                              <1> 
   134                              <1> struc ioReqPkt   ;IO Request Packet
   135                              <1> 
   136                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   137 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   138 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   139 00000016 ????????            <1>     .tfrlen dd ?  ;Number of Sectors/bytes to transfer
   140 0000001A ????????????????    <1>     .strtsc dq ?  ;Starting sector for transfer
   141 00000022 ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field if error
   142                              <1> 
   143                              <1> endstruc
   144                              <1> 
   145                              <1> struc ndInNoWaitPkt    ;Nondestructive Input No Wait Request Packet
   146                              <1>     
   147                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   148 0000000D ??                  <1>     .retbyt db ?  ;Byte read non destructively
   149                              <1> 
   150                              <1> endstruc
   151                              <1> 
   152                              <1> struc statusReqPkt   ;Status Request Packet
   153                              <1> 
   154                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   155                              <1> 
   156                              <1> endstruc
   157                              <1> 
   158                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
   159                              <1> 
   160                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   161                              <1>      
   162                              <1> endstruc
   163                              <1> 
   164                              <1> struc openReqPkt ;Open Device Request Packet
   165                              <1> 
   166                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   167                              <1>      
   168                              <1> endstruc
   169                              <1> 
   170                              <1> struc closeReqPkt ;Close Device Request Packet
   171                              <1> 
   172                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   173                              <1>      
   174                              <1> endstruc
   175                              <1> 
   176                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   177                              <1> 
   178                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   179                              <1>      
   180                              <1> endstruc
   181                              <1> 
   182                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   183                              <1> 
   184                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   185 0000000D ??                  <1>     .majfun db ?  ;Major function number
   186 0000000E ??                  <1>     .minfun db ?  ;Minor function number
   187 0000000F ????????????????    <1>     .rsival dq ?  ;Contents of RSI
   188 00000017 ????????????????    <1>     .rdival dq ?  ;Contents of RDI
   189 0000001F ????????????????    <1>     .ctlptr dq ?  ;Pointer to Generic IOCTL Request Packet
   190                              <1> 
   191                              <1> endstruc
   192                              <1> 
   193                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   194                              <1>     
   195                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   196                              <1> 
   197                              <1> endstruc
   198                              <1> 
   199                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   200                              <1>     
   201                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   202                              <1> 
   203                              <1> endstruc
   204                              <1> 
   205                              <1> 
   206                              <1> struc genioctlGetParamsTable
   207 00000000 ??                  <1>     .size           db ?
   208 00000001 ??????????????      <1>     .res            db 7 dup (?)
   209 00000008 ????????????????    <1>     .sectorSize     db 8 dup (?)  ;Only the lower dword is valid here
   210 00000010 ????????????????    <1>     .numSectors     db 8 dup (?)
   211                              <1> endstruc
   212                              <1> 
   213                              <1> ;THE WRITE STRUCT MUST BE A STRICT SUPERSET OF THE FORMAT STRUCT ALWAYS
   214                              <1> struc genioctlLBAformat
   215 00000000 ??                  <1>     .size           db ?
   216 00000001 ??                  <1>     .numSectors     db ?  ;Number of sectors to format
   217 00000002 ????????????        <1>     .res            db 6 dup (?)
   218 00000008 ????????????????    <1>     .startSector    db 8 dup (?)  ;Sector to start format at
   219                              <1> endstruc
   220                              <1> 
   221                              <1> struc genioctlLBAwrite
   222 00000000 ??                  <1>     .size           db ?
   223 00000001 ??                  <1>     .numSectors     db ?  ;Number of sectors to write
   224 00000002 ????????????        <1>     .res            db 6 dup (?)
   225 00000008 ????????????????    <1>     .startSector    db 8 dup (?)  ;Sector to start write at
   226 00000010 ????????????????    <1>     .xferBuffer     db 8 dup (?)  ;Transfer buffer for data
   227                              <1> endstruc
     6                                  %include "./src/mcon.inc"
     1                              <1> ;MCON screen capabilities
     2                              <1> 
     3                              <1> struc mScrCap
     4 00000000 ????                <1>     .wVer       dw ?    ;Upper byte, Major num (1). Lower byte, minor num (0)
     5 00000002 ????                <1>     .wLen       dw ?    ;Length of structure (15 bytes)
     6 00000004 ??                  <1>     .bScrNum    db ?    ;Number of screens supported by driver
     7 00000005 ????????????????    <1>     .pDevHlp    dq ?    ;Pointer to the mCon help routine
     8                              <1> endstruc
     9                              <1> 
    10                              <1> maxScr  equ 07h ;Screens 0 - 7 (so 8 screens)
    11                              <1> 
    12                              <1> DevHlp_ConsInputFilter  equ 5
    13                              <1> DevHlp_Signal_SM        equ 7
    14                              <1> DevHlp_ProcBlock        equ 9
    15                              <1> DevHlp_ProcRun          equ 10
    16                              <1> DevHlp_GetDOSVar        equ 16
     7                                  %include "./src/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1>     ret
    14                              <1> %endmacro
    15                              <1> 
    16                              <1> %macro cret 1
    17                              <1>     j%-1 short %%a
    18                              <1>     return
    19                              <1> %%a:
    20                              <1> %endmacro
    21                              <1> 
    22                              <1> %macro retz 0
    23                              <1> cret z
    24                              <1> %endmacro
    25                              <1> 
    26                              <1> %macro retnz 0
    27                              <1> cret nz
    28                              <1> %endmacro
    29                              <1> 
    30                              <1> %macro rete 0
    31                              <1> cret e
    32                              <1> %endmacro
    33                              <1> 
    34                              <1> %macro retne 0
    35                              <1> cret ne
    36                              <1> %endmacro
    37                              <1> 
    38                              <1> %macro retc 0
    39                              <1> cret c
    40                              <1> %endmacro
    41                              <1> 
    42                              <1> %macro retnc 0
    43                              <1> cret nc
    44                              <1> %endmacro
    45                              <1> 
    46                              <1> %macro retb 0
    47                              <1> cret b
    48                              <1> %endmacro
    49                              <1> 
    50                              <1> %macro retnb 0
    51                              <1> cret nb
    52                              <1> %endmacro
    53                              <1> 
    54                              <1> %macro reta 0
    55                              <1> cret a
    56                              <1> %endmacro
    57                              <1> 
    58                              <1> %macro retna 0
    59                              <1> cret na
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> %macro breakpoint 0
    63                              <1> xchg bx, bx
    64                              <1> %endmacro
     8                                  
     9                                  Segment cseg start=0 vstart=0
    10                                  %include "./src/mcdata.asm" ;Cannot put this in a separate segment due to reloc issues
     1                              <1> 
     2                              <1> ;Driver version number
     3                              <1> majVers equ 0
     4                              <1> minVers equ 2
     5                              <1> 
     6                              <1> conHdr:
     7 00000000 FFFFFFFFFFFFFFFF    <1>     dq -1
     8 00000008 7380                <1>     dw devDrvChar | devDrvIOCTL | devDrvMulti | devDrvFastOut | devDrvConOut | devDrvConIn
     9 0000000A [7600000000000000]  <1>     dq strategy
    10 00000012 [B500000000000000]  <1>     dq noOp    ;We don't use the interrupt endpoint.
    11 0000001A 434F4E2020202020    <1>     db "CON     "
    12                              <1> 
    13                              <1> funcTbl:
    14 00000022 2C04                <1>     dw init - funcTbl       ;Init function
    15 00000024 9300                <1>     dw noOp - funcTbl       ;Media Check
    16 00000026 9300                <1>     dw noOp - funcTbl       ;Build BPB
    17 00000028 9400                <1>     dw unkExit - funcTbl    ;IOCTL Input
    18 0000002A A100                <1>     dw read - funcTbl       ;Read
    19 0000002C ED00                <1>     dw ndRead - funcTbl     ;Non-destructive read
    20 0000002E 2101                <1>     dw inStatus - funcTbl   ;Input Status
    21 00000030 2E01                <1>     dw flushInBuf - funcTbl ;Input flush
    22 00000032 4E01                <1>     dw write - funcTbl      ;Write
    23 00000034 4E01                <1>     dw write - funcTbl      ;Write with verify
    24 00000036 9300                <1>     dw noOp - funcTbl       ;Output Status
    25 00000038 9300                <1>     dw noOp - funcTbl       ;Output Flush
    26 0000003A 9300                <1>     dw noOp - funcTbl       ;IOCTL Output
    27 0000003C 9300                <1>     dw noOp - funcTbl       ;Device Open
    28 0000003E 9300                <1>     dw noOp - funcTbl       ;Device Close
    29 00000040 9300                <1>     dw noOp - funcTbl       ;Removable Media
    30 00000042 9400                <1>     dw unkExit - funcTbl    ;Reserved function
    31 00000044 9400                <1>     dw unkExit - funcTbl    ;Reserved function
    32 00000046 9400                <1>     dw unkExit - funcTbl    ;Reserved function
    33                              <1> ; New functions
    34 00000048 7201                <1>     dw genIOCTL - funcTbl   ;Generic IOCTL
    35                              <1> 
    36                              <1> funcTblE equ ($ - funcTbl)/2    ;Compute number of entries
    37                              <1> 
    38 0000004A 00                  <1> bConBuf     db 0    ;Single byte input buffer
    39 0000004B 00                  <1> bKeybWait   db 0    ;Set if we are waiting on Int 36h for a keystroke
    40                              <1> 
    41 0000004C 0000000000000000    <1> pOldKbdIntr dq 0    ;Ptr to the Keyboard interrupt 
    42 00000054 0000000000000000    <1> pOldKbdHdlr dq 0    ;Ptr to the Keyboard service routine
    43 0000005C [B500000000000000]  <1> pDevHlp     dq noOp ;Ptr to the DOS session help interface. Default to NOP
    44 00000064 FFFFFFFFFFFFFFFF    <1> pScrIoOk    dq -1   ;Ptr to the DOS variable that is set if screen IO is ok
    45                              <1> 
    46                              <1> myIdt:
    47 0000006C 0000                <1> .limit  dw 0
    48 0000006E 0000000000000000    <1> .base   dq 0
    11                                  %include "./src/mccode.asm"
     1                              <1> ;This driver is designed to work in the MDOS environment. 
     2                              <1> 
     3                              <1> strategy:
     4                              <1> ;DOS calls this function with rbx=Ptr to request header.
     5                              <1> ;Rather than saving the 
     6 00000076 50                  <1>     push rax
     7 00000077 53                  <1>     push rbx
     8 00000078 51                  <1>     push rcx
     9 00000079 52                  <1>     push rdx
    10 0000007A 56                  <1>     push rsi
    11 0000007B 57                  <1>     push rdi
    12 0000007C 55                  <1>     push rbp
    13 0000007D 4150                <1>     push r8 ;Use r8 as the static pointer to the request packet!
    14 0000007F 4989D8              <1>     mov r8, rbx 
    15 00000082 6641C740030000      <1>     mov word [r8 + drvReqHdr.status], 0    ;Ensure status clear (should be!)
    16 00000089 410FB64002          <1>     movzx eax, byte [r8 + drvReqHdr.cmdcde]
    17 0000008E 3D14000000          <1>     cmp eax, funcTblE   
    18 00000093 7321                <1>     jae short unkExit       ;If cmdcde is past the end of the table, error!
    19 00000095 488D1D86FFFFFF      <1>     lea rbx, funcTbl        ;Else get pointer to function
    20 0000009C 0FB71443            <1>     movzx edx, word [rbx + 2*rax]   
    21 000000A0 4801D3              <1>     add rbx, rdx
    22 000000A3 FFD3                <1>     call rbx        
    23                              <1> exit:
    24 000000A5 66418148030001      <1>     or word [r8 + drvReqHdr.status], drvDonStatus    ;Set done bit!
    25                              <1> .err:
    26 000000AC 4158                <1>     pop r8
    27 000000AE 5D                  <1>     pop rbp
    28 000000AF 5F                  <1>     pop rdi
    29 000000B0 5E                  <1>     pop rsi
    30 000000B1 5A                  <1>     pop rdx
    31 000000B2 59                  <1>     pop rcx
    32 000000B3 5B                  <1>     pop rbx
    33 000000B4 58                  <1>     pop rax
    34                              <1> noOp:
    35                              <1>     return
    13 000000B5 C3                  <2>  ret
    36                              <1> 
    37                              <1> unkExit:
    38 000000B6 B003                <1>     mov al, drvBadCmd
    39                              <1> errorExit:
    40                              <1> ;Jump to with al=Standard Error code
    41 000000B8 66B80080            <1>     mov ax, drvErrStatus    ;Set error bit, and NOT done bit!
    42 000000BC 6641894003          <1>     mov word [r8 + drvReqHdr.status], ax
    43 000000C1 EBE9                <1>     jmp short exit.err
    44                              <1> 
    45                              <1> read:    ;Read Chars
    46 000000C3 B005                <1>     mov al, 05h ;Bad request structure length?
    47 000000C5 4180382A            <1>     cmp byte [r8 + drvReqHdr.hdrlen], ioReqPkt_size
    48 000000C9 75ED                <1>     jne errorExit
    49                              <1> 
    50 000000CB 498B780E            <1>     mov rdi, qword [r8 + ioReqPkt.bufptr]  ;Point rdi to caller buffer
    51 000000CF 31C9                <1>     xor ecx, ecx    ;Zero the char counter
    52                              <1> .cre1:
    53 000000D1 413B4816            <1>     cmp ecx, dword [r8 + ioReqPkt.tfrlen]
    54 000000D5 7424                <1>     je .cre2
    55 000000D7 803D6CFFFFFF00      <1>     cmp byte [bConBuf], 0   ;Does the buffer contain a zero?
    56 000000DE 7520                <1>     jnz .cre3   ;No, get the buffer value
    57 000000E0 31C0                <1>     xor eax, eax
    58 000000E2 CD36                <1>     int 36h
    59 000000E4 663D0072            <1>     cmp ax, 7200h   ;CTRL + PrnScr? 
    60 000000E8 7502                <1>     jne .cre11
    61 000000EA B010                <1>     mov al, 10h     ;Store ^P in al!
    62                              <1> .cre11:
    63 000000EC AA                  <1>     stosb
    64 000000ED 84C0                <1>     test al, al ;Was the ascii code stored 0?
    65 000000EF 7506                <1>     jnz .cre12  ;No, skip storing scancode in buffer
    66 000000F1 882553FFFFFF        <1>     mov byte [bConBuf], ah  ;Save scancode
    67                              <1> .cre12:
    68 000000F7 FFC1                <1>     inc ecx ;Inc chars stored in buffer
    69 000000F9 EBD6                <1>     jmp short .cre1
    70                              <1> .cre2:
    71 000000FB 41894816            <1>     mov dword [r8 + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
    72                              <1>     return
    13 000000FF C3                  <2>  ret
    73                              <1> .cre3:
    74 00000100 8A0544FFFFFF        <1>     mov al, byte [bConBuf]  ;Get the buffer value
    75 00000106 C6053DFFFFFF00      <1>     mov byte [bConBuf], 0   ;Reset the buffer value
    76 0000010D EBDD                <1>     jmp short .cre11
    77                              <1> 
    78                              <1> ndRead:  ;Non destructive read chars
    79 0000010F B005                <1>     mov al, 05h ;Bad request structure length?
    80 00000111 4180380E            <1>     cmp byte [r8 + drvReqHdr.hdrlen], ndInNoWaitPkt_size
    81 00000115 75A1                <1>     jne errorExit
    82 00000117 803D2CFFFFFF00      <1>     cmp byte [bConBuf], 0
    83 0000011E 751B                <1>     jnz .cnr2
    84 00000120 B401                <1>     mov ah, 01h     ;Get key if exists
    85 00000122 CD36                <1>     int 36h
    86 00000124 740D                <1>     jz .cnr1        ;If zero clear => no key, go forwards
    87                              <1>     ;Keystroke available
    88 00000126 663D0072            <1>     cmp ax, 7200h   ;CTRL + PrnScr?
    89 0000012A 7502                <1>     jne .cnr0
    90 0000012C B010                <1>     mov al, 10h     ;Report ^P
    91                              <1> .cnr0:
    92 0000012E 4188400D            <1>     mov byte [r8 + ndInNoWaitPkt.retbyt], al   ;Move char in al
    93                              <1>     return
    13 00000132 C3                  <2>  ret
    94                              <1> .cnr1: ;No keystroke available
    95 00000133 6641C740030002      <1>     mov word [r8 + ndInNoWaitPkt.status], drvBsyStatus   ;Set busy bit
    96                              <1>     return
    13 0000013A C3                  <2>  ret
    97                              <1> .cnr2:
    98 0000013B 8A0509FFFFFF        <1>     mov al, byte [bConBuf]  ;Copy scancode but dont reset it
    99 00000141 EBEB                <1>     jmp short .cnr0   ;Keystroke is available clearly
   100                              <1> 
   101                              <1> inStatus:         ;Get Input Status
   102 00000143 B005                <1>     mov al, 05h ;Bad request structure length?
   103 00000145 4180380D            <1>     cmp byte [r8 + drvReqHdr.hdrlen], statusReqPkt_size
   104 00000149 0F8569FFFFFF        <1>     jne errorExit
   105                              <1>     return ;Exit, device ready
    13 0000014F C3                  <2>  ret
   106                              <1> 
   107                              <1> flushInBuf:   ;Flush Input Buffers
   108 00000150 B005                <1>     mov al, 05h ;Bad request structure length?
   109 00000152 4180380D            <1>     cmp byte [r8 + drvReqHdr.hdrlen], statusReqPkt_size
   110 00000156 0F855CFFFFFF        <1>     jne errorExit
   111 0000015C C605E7FEFFFF00      <1>     mov byte [bConBuf], 0   ;Clear buffer
   112                              <1> .cfib0:
   113 00000163 B401                <1>     mov ah, 01      ;Get buffer status
   114 00000165 CD36                <1>     int 36h
   115                              <1>     retz            ;If zero clear => no more keys to read
    23                              <2> cret z
    17 00000167 7501                <3>  j%-1 short %%a
    18                              <3>  return
    13 00000169 C3                  <4>  ret
    19                              <3> %%a:
   116 0000016A 30E4                <1>     xor ah, ah
   117 0000016C CD36                <1>     int 36h ;Read key to flush from buffer
   118 0000016E EBF3                <1>     jmp short .cfib0
   119                              <1> 
   120                              <1> write:   ;Write Chars
   121 00000170 B005                <1>     mov al, 05h ;Bad request structure length?
   122 00000172 4180382A            <1>     cmp byte [r8 + drvReqHdr.hdrlen], ioReqPkt_size
   123 00000176 0F853CFFFFFF        <1>     jne errorExit
   124                              <1> 
   125 0000017C 498B700E            <1>     mov rsi, qword [r8 + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   126 00000180 31C9                <1>     xor ecx, ecx    ;Zero the char counter
   127                              <1> .cw1: 
   128 00000182 413B4816            <1>     cmp ecx, dword [r8 + ioReqPkt.tfrlen]
   129 00000186 7407                <1>     je .cw2
   130 00000188 AC                  <1>     lodsb   ;Get char into al, and inc rsi
   131 00000189 CD29                <1>     int 29h ;Fast print char
   132 0000018B FFC1                <1>     inc ecx
   133 0000018D EBF3                <1>     jmp short .cw1 ;keep printing until all chars printed
   134                              <1> .cw2:
   135 0000018F 41894816            <1>     mov dword [r8 + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   136                              <1>     return
    13 00000193 C3                  <2>  ret
   137                              <1> ; -------------------- NEW FUNCTIONS -------------------- 
   138                              <1> genIOCTL:
   139                              <1> ;Only one function, MScrCap. Declares the presence of a multitasker
   140                              <1> ; to the driver!
   141                              <1> ;Do all checks to ensure not an accidental call.
   142 00000194 498B501F            <1>     mov rdx, qword [r8 + ioctlReqPkt.ctlptr]
   143 00000198 80FD03              <1>     cmp ch, 03h     ;Sent to the CON? (Formally, SCR$)?
   144 0000019B 7523                <1>     jne .exitBad
   145 0000019D 80F940              <1>     cmp cl, 40h     ;Get Multitasking Screen Capacities/init multitaskting?
   146 000001A0 745B                <1>     je .iosc_init
   147 000001A2 80F941              <1>     cmp cl, 41h     ;Locate SIB
   148 000001A5 7455                <1>     je .iosc_ls
   149 000001A7 80F942              <1>     cmp cl, 42h     ;Save Segment
   150 000001AA 7450                <1>     je .iosc_ss
   151 000001AC 80F943              <1>     cmp cl, 43h     ;Restore Segment
   152 000001AF 744B                <1>     je .iosc_rs
   153 000001B1 80F944              <1>     cmp cl, 44h     ;Enable IO
   154 000001B4 7446                <1>     je .iosc_ei
   155 000001B6 80F945              <1>     cmp cl, 45h     ;Initialise Screen
   156 000001B9 7441                <1>     je .iosc_is    
   157 000001BB 80F946              <1>     cmp cl, 46h     ;Deactivate Multitasking capabilities
   158 000001BE 7409                <1>     je .iosc_deinst
   159                              <1> .exitBad:
   160 000001C0 6641C740030380      <1>     mov word [r8 + drvReqHdr.status], drvErrStatus | drvBadCmd
   161 000001C7 F9                  <1>     stc
   162                              <1>     return
    13 000001C8 C3                  <2>  ret
   163                              <1> .iosc_deinst:
   164                              <1> ;Reset the internal vars to set CON back to single tasking mode!
   165 000001C9 FA                  <1>     cli
   166 000001CA 488B157BFEFFFF      <1>     mov rdx, qword [pOldKbdIntr]
   167 000001D1 B8F1000000          <1>     mov eax, 0F1h
   168 000001D6 E83F020000          <1>     call installInterrupt
   169 000001DB 488B1572FEFFFF      <1>     mov rdx, qword [pOldKbdHdlr]
   170 000001E2 B836000000          <1>     mov eax, 036h
   171 000001E7 E82E020000          <1>     call installInterrupt
   172 000001EC 488D05C2FEFFFF      <1>     lea rax, noOp
   173 000001F3 48890562FEFFFF      <1>     mov qword [pDevHlp], rax    ;Restore the do nothing function!
   174 000001FA FB                  <1>     sti
   175                              <1>     return
    13 000001FB C3                  <2>  ret
   176                              <1> .iosc_ls:
   177                              <1> ;Locate SIB
   178                              <1> .iosc_ss:
   179                              <1> ;Save Segment
   180                              <1> .iosc_rs:
   181                              <1> ;Restore Segment
   182                              <1> .iosc_ei:
   183                              <1> ;Renable IO
   184                              <1> .iosc_is:
   185                              <1> ;Initialise screen
   186                              <1>     return
    13 000001FC C3                  <2>  ret
   187                              <1> .iosc_init:
   188 000001FD 66813A0001          <1>     cmp word [rdx + mScrCap.wVer], 0100h
   189 00000202 75BC                <1>     jne .exitBad
   190 00000204 66817A020D00        <1>     cmp word [rdx + mScrCap.wLen], mScrCap_size
   191 0000020A 75B4                <1>     jne .exitBad
   192                              <1> ;Here we have verified we are ok! Proceed.
   193                              <1> ;This IOCTL is equivalent to in MTDOS the CON reporting caps during driver init.
   194 0000020C C6420408            <1>     mov byte [rdx + mScrCap.bScrNum], (maxScr + 1)
   195 00000210 488D0569000000      <1>     lea rax, mConHlp
   196 00000217 48874205            <1>     xchg rax, qword [rdx + mScrCap.pDevHlp] ;For now, still provide this iface
   197                              <1>     ;mov rax, qword [rdx + mScrCap.pDevHlp]  ;Get the devHlp pointer
   198 0000021B 4889053AFEFFFF      <1>     mov qword [pDevHlp], rax
   199                              <1> 
   200                              <1> ;Now setup the pointer to the DOSMGR ScrIoOk byte
   201 00000222 31C0                <1>     xor eax, eax    ;Get var 0 (ScrIoOk)
   202 00000224 B901000000          <1>     mov ecx, 1      ;Length 1
   203 00000229 BA10000000          <1>     mov edx, DevHlp_GetDOSVar     ;Get ScrIoOk Var
   204 0000022E FF1528FEFFFF        <1>     call qword [pDevHlp]
   205 00000234 48890529FEFFFF      <1>     mov qword [pScrIoOk], rax   ;Store the pointer now!
   206                              <1> 
   207                              <1> ;Now install the multitasking keyboard interrupt routines!
   208                              <1> ;DO IRQ1
   209 0000023B B8F1000000          <1>     mov eax, 0F1h   ;Get IRQ1 handler in rbx
   210 00000240 E8FF010000          <1>     call getIntHdlr
   211 00000245 48891D00FEFFFF      <1>     mov qword [pOldKbdIntr], rbx
   212 0000024C 488D15C6000000      <1>     lea rdx, keybIntr
   213 00000253 B8F1000000          <1>     mov eax, 0F1h
   214 00000258 E8BD010000          <1>     call installInterrupt
   215                              <1> ;DO Int 36h
   216 0000025D B836000000          <1>     mov eax, 036h   ;Get Int 36h handler in rbx
   217 00000262 E8DD010000          <1>     call getIntHdlr
   218 00000267 48891DE6FDFFFF      <1>     mov qword [pOldKbdHdlr], rbx
   219 0000026E 488D1522010000      <1>     lea rdx, keybHdlr
   220 00000275 B836000000          <1>     mov eax, 036h
   221 0000027A E89B010000          <1>     call installInterrupt
   222                              <1> 
   223                              <1>     return
    13 0000027F C3                  <2>  ret
   224                              <1> ;-------------------------------------------
   225                              <1> ;       mConHlp dispatch and routines
   226                              <1> ;-------------------------------------------
   227                              <1> 
   228                              <1> mConHlp:
   229                              <1> ;AL = 0: Get current screen number
   230                              <1> ;AL = 1: Set new screen number
   231                              <1> ;AL = 2: Reset the screen (CLS)
   232                              <1> ;Al = 3: Cancel help pointer support
   233 00000280 85C0                <1>     test eax, eax
   234 00000282 7412                <1>     jz getScreen
   235 00000284 FFC8                <1>     dec eax
   236 00000286 741B                <1>     jz swapScreen
   237 00000288 FFC8                <1>     dec eax
   238 0000028A 742B                <1>     jz resetScreen
   239 0000028C FFC8                <1>     dec eax
   240 0000028E 0F8435FFFFFF        <1>     jz genIOCTL.iosc_deinst ;Cancel help pointer support
   241 00000294 F9                  <1>     stc
   242                              <1>     return
    13 00000295 C3                  <2>  ret
   243                              <1> getScreen:
   244 00000296 53                  <1>     push rbx
   245 00000297 B8000F0000          <1>     mov eax, 0F00h
   246 0000029C CD30                <1>     int 30h
   247 0000029E 0FB6C7              <1>     movzx eax, bh
   248 000002A1 5B                  <1>     pop rbx
   249                              <1>     return
    13 000002A2 C3                  <2>  ret
   250                              <1> swapScreen:
   251                              <1> ;If the screen number is above the max screen number we return error!
   252                              <1> ;This routine is signalled by the task swapping routine.
   253 000002A3 0FB6C3              <1>     movzx eax, bl ;Get the screen number
   254 000002A6 3D07000000          <1>     cmp eax, maxScr
   255 000002AB 7708                <1>     ja .err
   256 000002AD 0D00050000          <1>     or eax, 0500h   
   257 000002B2 CD30                <1>     int 30h         ;Swap active page on the VGA!
   258                              <1>     return
    13 000002B4 C3                  <2>  ret
   259                              <1> .err:
   260 000002B5 F9                  <1>     stc
   261                              <1>     return
    13 000002B6 C3                  <2>  ret
   262                              <1> resetScreen:
   263                              <1> ;Resets the currently active screen!
   264 000002B7 B40B                <1>     mov ah, 0Bh  ; Set overscan to black (when Graphics becomes supported)
   265 000002B9 31DB                <1>     xor ebx, ebx
   266 000002BB CD30                <1>     int 30h
   267 000002BD B40F                <1>     mov ah, 0Fh ;Get screen mode
   268 000002BF CD30                <1>     int 30h
   269 000002C1 53                  <1>     push rbx    ;Save the screen number on stack
   270 000002C2 0FB6D4              <1>     movzx edx, ah   ;Get number of columns in dl
   271 000002C5 FECA                <1>     dec dl
   272 000002C7 B619                <1>     mov dh, 25  ;Number of rows is standard
   273 000002C9 31C0                <1>     xor eax, eax
   274 000002CB 89C1                <1>     mov ecx, eax
   275 000002CD B707                <1>     mov bh, 7   ;Screen attributes
   276 000002CF B406                <1>     mov ah, 6   ;Scroll
   277 000002D1 CD30                <1>     int 30h
   278 000002D3 31D2                <1>     xor edx, edx    ;Set cursor coordinates to top left of screen
   279 000002D5 5B                  <1>     pop rbx     ;Get back the screen number
   280 000002D6 B402                <1>     mov ah, 2
   281 000002D8 CD30                <1>     int 30h
   282                              <1>     return
    13 000002DA C3                  <2>  ret
   283                              <1>     
   284                              <1> ;------------- Driver built-in Interrupt Routines -------------
   285                              <1> fastOutput:         ;This CON driver supports Int 29h
   286                              <1> ;Called with char to transfer in al
   287 000002DB 50                  <1>     push rax
   288 000002DC B40E                <1>     mov ah, 0Eh
   289 000002DE CD30                <1>     int 30h
   290 000002E0 58                  <1>     pop rax
   291 000002E1 48CF                <1>     iretq
   292                              <1> 
   293                              <1> ctrlBreak:
   294                              <1> ;CON Int 3Bh handler to detect CTRL+BREAK.
   295 000002E3 50                  <1>     push rax
   296 000002E4 52                  <1>     push rdx
   297                              <1> ;Simulate an interrupt call to the BIOS to pull the key out
   298                              <1> ; from the buffer.
   299 000002E5 4889E2              <1>     mov rdx, rsp
   300 000002E8 31C0                <1>     xor eax, eax
   301 000002EA 668CD0              <1>     mov ax, ss
   302 000002ED 50                  <1>     push rax
   303 000002EE 52                  <1>     push rdx
   304 000002EF 9C                  <1>     pushfq
   305 000002F0 668CC8              <1>     mov ax, cs
   306 000002F3 50                  <1>     push rax
   307 000002F4 31C0                <1>     xor eax, eax    ;Getch, BIOS Places a zero word in the keyboard buffer
   308 000002F6 FF1558FDFFFF        <1>     call qword [pOldKbdHdlr]    ;Pull the zero word out of the keyb buffer
   309 000002FC B803000000          <1>     mov eax, 03h                ;Replace it with a ^C char
   310 00000301 BA05000000          <1>     mov edx, DevHlp_ConsInputFilter
   311 00000306 FF1550FDFFFF        <1>     call qword [pDevHlp]        ;Ask DOS if it wants to eat the ^C
   312 0000030C 7407                <1>     jz .exit                    ;Jump if DOS ate ^C :(
   313 0000030E C60535FDFFFF03      <1>     mov byte [bConBuf], 03h     ;Place a ^C in buffer
   314                              <1> .exit:
   315 00000315 5A                  <1>     pop rdx
   316 00000316 58                  <1>     pop rax
   317 00000317 48CF                <1>     iretq
   318                              <1> 
   319                              <1> keybIntr:        ;New Keyboard Interrupt Hdlr
   320 00000319 50                  <1>     push rax        ;Save RAX as a trashed reg
   321 0000031A 52                  <1>     push rdx
   322                              <1> ;Simulate an IRQ entry to old kbdHldr
   323 0000031B 4889E2              <1>     mov rdx, rsp
   324 0000031E 31C0                <1>     xor eax, eax
   325 00000320 668CD0              <1>     mov ax, ss
   326 00000323 50                  <1>     push rax
   327 00000324 52                  <1>     push rdx
   328 00000325 9C                  <1>     pushfq
   329 00000326 668CC8              <1>     mov ax, cs
   330 00000329 50                  <1>     push rax
   331 0000032A FF151CFDFFFF        <1>     call qword [pOldKbdIntr]    ;Do the SCP/BIOS kbd handler code!
   332                              <1> 
   333 00000330 4889E2              <1>     mov rdx, rsp
   334 00000333 31C0                <1>     xor eax, eax
   335 00000335 668CD0              <1>     mov ax, ss
   336 00000338 50                  <1>     push rax
   337 00000339 52                  <1>     push rdx
   338 0000033A 9C                  <1>     pushfq
   339 0000033B 668CC8              <1>     mov ax, cs
   340 0000033E 50                  <1>     push rax
   341 0000033F B800010000          <1>     mov eax, 0100h              ;Now read ahead, under our handler
   342 00000344 FF150AFDFFFF        <1>     call qword [pOldKbdHdlr]    ;Gets the SC/ASCII pair in ax
   343 0000034A BA05000000          <1>     mov edx, DevHlp_ConsInputFilter
   344 0000034F FF1507FDFFFF        <1>     call qword [pDevHlp]
   345 00000355 7519                <1>     jnz .keepChar
   346                              <1>     ;Else remove the char from the buffer
   347 00000357 4889E2              <1>     mov rdx, rsp
   348 0000035A 31C0                <1>     xor eax, eax
   349 0000035C 668CD0              <1>     mov ax, ss
   350 0000035F 50                  <1>     push rax
   351 00000360 52                  <1>     push rdx
   352 00000361 9C                  <1>     pushfq
   353 00000362 668CC8              <1>     mov ax, cs
   354 00000365 50                  <1>     push rax
   355 00000366 31C0                <1>     xor eax, eax
   356 00000368 FF15E6FCFFFF        <1>     call qword [pOldKbdHdlr]    ;Gets the SC/ASCII pair in ax
   357 0000036E EB23                <1>     jmp short .exit
   358                              <1> .keepChar:
   359 00000370 FA                  <1>     cli
   360 00000371 F605D3FCFFFFFF      <1>     test byte [bKeybWait], -1  
   361 00000378 7419                <1>     jz .exit
   362 0000037A 53                  <1>     push rbx
   363 0000037B 51                  <1>     push rcx
   364 0000037C 488D1DC8FCFFFF      <1>     lea rbx, bKeybWait  ;Run all processes with this identifier
   365 00000383 C60300              <1>     mov byte [rbx], 0   ;Clear the flag first
   366 00000386 BA0A000000          <1>     mov edx, DevHlp_ProcRun  ;ProcRun
   367 0000038B FF15CBFCFFFF        <1>     call qword [pDevHlp]
   368 00000391 59                  <1>     pop rcx
   369 00000392 5B                  <1>     pop rbx
   370                              <1> .exit:
   371 00000393 5A                  <1>     pop rdx
   372 00000394 58                  <1>     pop rax
   373 00000395 48CF                <1>     iretq
   374                              <1> 
   375                              <1> 
   376                              <1> keybHdlr:   ;Int 36h
   377 00000397 84E4                <1>     test ah, ah
   378 00000399 740B                <1>     je .readChar
   379 0000039B 80FC01              <1>     cmp ah, 1
   380 0000039E 7465                <1>     je .lookahead
   381 000003A0 FF25AEFCFFFF        <1>     jmp qword [pOldKbdHdlr]
   382                              <1> .readChar:
   383 000003A6 50                  <1>     push rax    ;Push original function number on the stack
   384 000003A7 53                  <1>     push rbx
   385 000003A8 51                  <1>     push rcx
   386 000003A9 52                  <1>     push rdx
   387                              <1> .readChLp:
   388 000003AA 488B1DB3FCFFFF      <1>     mov rbx, qword [pScrIoOk]
   389 000003B1 F603FF              <1>     test byte [rbx], -1
   390 000003B4 750F                <1>     jnz .okToRead
   391 000003B6 31C9                <1>     xor ecx, ecx
   392 000003B8 BA09000000          <1>     mov edx, DevHlp_ProcBlock  ;Proc block, non-interruptable
   393 000003BD FF1599FCFFFF        <1>     call qword [pDevHlp]    ;Use this var as identifier.
   394 000003C3 EBE5                <1>     jmp short .readChLp ;Check again!
   395                              <1> .okToRead:
   396                              <1> ;Now we simulate a call into 36h/AH=01h - Get keyboard buffer status
   397 000003C5 FA                  <1>     cli
   398 000003C6 4889E2              <1>     mov rdx, rsp
   399 000003C9 31C0                <1>     xor eax, eax
   400 000003CB 668CD0              <1>     mov ax, ss
   401 000003CE 50                  <1>     push rax
   402 000003CF 52                  <1>     push rdx
   403 000003D0 9C                  <1>     pushfq
   404 000003D1 668CC8              <1>     mov ax, cs
   405 000003D4 50                  <1>     push rax
   406 000003D5 B800010000          <1>     mov eax, 0100h  ;Get the keyb status
   407 000003DA FF1574FCFFFF        <1>     call qword [pOldKbdHdlr]    ;Interrupts remain set on return
   408 000003E0 7519                <1>     jnz .doCharRead
   409                              <1> ;If the char isn't there, we gotta pblock until it is.
   410 000003E2 488D1D62FCFFFF      <1>     lea rbx, bKeybWait
   411 000003E9 C603FF              <1>     mov byte [rbx], -1
   412 000003EC 09C9                <1>     or ecx, ecx
   413 000003EE BA09000000          <1>     mov edx, DevHlp_ProcBlock  ;Proc block, non-interruptable
   414 000003F3 FF1563FCFFFF        <1>     call qword [pDevHlp]    ;Use this var as identifier.
   415 000003F9 EBAF                <1>     jmp short .readChLp ;Check again with CLI set!
   416                              <1> .doCharRead:
   417 000003FB 5A                  <1>     pop rdx
   418 000003FC 59                  <1>     pop rcx
   419 000003FD 5B                  <1>     pop rbx
   420 000003FE 58                  <1>     pop rax
   421                              <1> .goKbd:
   422 000003FF FF254FFCFFFF        <1>     jmp qword [pOldKbdHdlr]
   423                              <1> .lookahead:
   424 00000405 53                  <1>     push rbx
   425 00000406 488B1D57FCFFFF      <1>     mov rbx, qword [pScrIoOk]   ;Can we check?
   426 0000040D F603FF              <1>     test byte [rbx], -1
   427 00000410 5B                  <1>     pop rbx
   428 00000411 75EC                <1>     jnz .goKbd  ;If we can, do it!
   429 00000413 80642410FE          <1>     and byte [rsp + 2*8], ~1    ;Clear CF of flags
   430 00000418 48CF                <1>     iretq
   431                              <1> 
   432                              <1> installInterrupt:
   433                              <1> ;Writes the interrupt in the right place in the table
   434                              <1>     ;al = Interrupt number
   435                              <1>     ;rdx -> Handler to install
   436 0000041A 0F010D4BFCFFFF      <1>     sidt [myIdt]
   437 00000421 0FB6C0              <1>     movzx eax, al
   438 00000424 4892                <1>     xchg rdx, rax
   439 00000426 48C1E204            <1>     shl rdx, 4h     ;Multiply IDT entry number by 16
   440 0000042A 4803153DFCFFFF      <1>     add rdx, qword [myIdt.base]    
   441 00000431 668902              <1>     mov word [rdx], ax  ;Get low word into offset 15...0
   442 00000434 48C1E810            <1>     shr rax, 10h    ;Bring next word low
   443 00000438 66894206            <1>     mov word [rdx + 6], ax  ;Get low word into offset 31...16
   444 0000043C 48C1E810            <1>     shr rax, 10h    ;Bring last dword low
   445 00000440 894208              <1>     mov dword [rdx + 8], eax
   446 00000443 C3                  <1>     ret
   447                              <1> getIntHdlr:
   448                              <1> ;Gets an interrupt value. 
   449                              <1> ;Input: al = Interrupt number
   450                              <1> ;Output: rbx = Interrupt Vector
   451 00000444 50                  <1>     push rax
   452 00000445 B802120000          <1>     mov eax, 1202h  ;Get Interrupt handler in rbx
   453 0000044A CD2F                <1>     int 2Fh
   454 0000044C 58                  <1>     pop rax
   455                              <1>     return
    13 0000044D C3                  <2>  ret
   456                              <1>     ;sidt [myIdt]
   457                              <1>     ;movzx eax, al
   458                              <1>     ;shl rax, 4h     ;Multiply IDT entry number by 16 (Size of IDT entry)
   459                              <1>     ;add rax, qword [myIdt.base]    
   460                              <1>     ;xor ebx, ebx
   461                              <1>     ;mov ebx, dword [rax + 8]    ;Get bits 63...32
   462                              <1>     ;shl rbx, 10h    ;Push the high dword high
   463                              <1>     ;mov bx, word [rax + 6]      ;Get bits 31...16
   464                              <1>     ;shl rbx, 10h    ;Push word 2 into posiiton
   465                              <1>     ;mov bx, word [rax]          ;Get bits 15...0
   466                              <1>     ;return
   467                              <1> 
   468                              <1> ;------------------ EJECT POINT ------------------
   469                              <1> 
   470                              <1> init:
   471                              <1> ;Start by hooking int 3Bh, int 29h and 0F1h (IRQ1) as part of the CON driver
   472                              <1> ;DO FASTOUT
   473 0000044E 488D1586FEFFFF      <1>     lea rdx, fastOutput
   474 00000455 B829000000          <1>     mov eax, 29h
   475 0000045A E8BBFFFFFF          <1>     call installInterrupt
   476                              <1> ;DO CTRL+BREAK
   477 0000045F 488D157DFEFFFF      <1>     lea rdx, ctrlBreak
   478 00000466 B83B000000          <1>     mov eax, 3Bh
   479 0000046B E8AAFFFFFF          <1>     call installInterrupt
   480                              <1> .ci0:
   481 00000470 B401                <1>     mov ah, 01      ;Get buffer status
   482 00000472 CD36                <1>     int 36h
   483 00000474 7406                <1>     jz .ci1      ;If zero clear => no more keys to read
   484 00000476 30E4                <1>     xor ah, ah
   485 00000478 CD36                <1>     int 36h ;Read key to flush from buffer
   486 0000047A EBF4                <1>     jmp short .ci0
   487                              <1> .ci1:
   488 0000047C B800050000          <1>     mov eax, 0500h  ;Set page zero as the default page
   489 00000481 CD30                <1>     int 30h
   490 00000483 B402                <1>     mov ah, 02h
   491 00000485 31D2                <1>     xor edx, edx    ;Set screen cursor to top right corner
   492 00000487 88D7                <1>     mov bh, dl      ;Set cursor for page 0
   493 00000489 CD30                <1>     int 30h
   494 0000048B B707                <1>     mov bh, 07h     ;Grey/Black attribs
   495 0000048D B800060000          <1>     mov eax, 0600h  ;Clear whole screen
   496 00000492 CD30                <1>     int 30h
   497                              <1> 
   498 00000494 B800510000          <1>     mov eax, 5100h
   499 00000499 CD21                <1>     int 21h             ;Get current PSP ptr
   500 0000049B 4881FB09000000      <1>     cmp rbx, 9          ;If we are being used as a Kernel driver, no msg!
   501 000004A2 740E                <1>     je skipMsg
   502                              <1> ;Else, print message!
   503 000004A4 488D1513000000      <1>     lea rdx, helloStr   ;Print install string
   504 000004AB B800090000          <1>     mov eax, 0900h
   505 000004B0 CD21                <1>     int 21h
   506                              <1> skipMsg:
   507 000004B2 488D0595FFFFFF      <1>     lea rax, init   ;Eject init
   508 000004B9 4989400E            <1>     mov qword [r8 + initReqPkt.endptr], rax
   509                              <1>     return
    13 000004BD C3                  <2>  ret
   510                              <1> 
   511 000004BE 2D2D2D20496E737461- <1> helloStr    db  "--- Installing MCON Device Driver V"
   511 000004C7 6C6C696E67204D434F- <1>
   511 000004D0 4E2044657669636520- <1>
   511 000004D9 4472697665722056    <1>
   512 000004E1 302E30              <1>             db  majVers+"0",".",minVers/10+"0"
   513 000004E4 32202D2D2D0A0D24    <1>             db (minVers-minVers/10*10)+"0", " ---", 10,13,"$"
   513          ------------------  <1>  info: assembly required 1+2+2 passes

